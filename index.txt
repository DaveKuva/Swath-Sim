<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Chosen Palette: Deep Space -->
    <!-- Application Structure Plan: The application's core is a real-time 3D visualization, which is the most effective way to represent spatial satellite data. The original structure of a main canvas and slide-out control panels is retained for its proven usability. To meet the goal of making data more consumable, I've introduced a third, dedicated 'Analysis' panel. This creates a task-oriented user flow: 1) Observe satellites in the 3D environment. 2) Select a satellite to see its live data. 3) Open the Analysis panel to explore a chart of its altitude over a full orbit. This layered approach allows users to move from general observation to specific, quantitative analysis, translating raw orbital mechanics into an easily digestible chart and fulfilling the core objective of synthesizing complex information. -->
    <!-- Visualization & Content Choices: 
        - Report Info: Real-time satellite position, velocity, orbit path. Goal: Explore spatial relationships. Viz/Presentation: 3D interactive scene. Interaction: Camera pan/zoom/rotate, focus tracking. Justification: Provides intuitive, contextual understanding of satellite orbits in relation to Earth, which is impossible in 2D. Library/Method: Three.js.
        - Report Info: Satellite altitude variation over time. Goal: Analyze change and patterns. Viz/Presentation: 2D Line Chart. Interaction: View chart for any selected satellite. Justification: Converts complex orbital propagation data into a clear, quantitative visual, revealing key characteristics like apogee and perigee at a glance. This makes the data easily consumable as requested. Library/Method: Chart.js/Canvas.
        - Report Info: Application controls (camera, focus, visualization toggles). Goal: User configuration. Viz/Presentation: Interactive UI panels with buttons, sliders, toggles. Interaction: Click/drag controls to modify the 3D scene in real-time. Justification: Groups all user inputs logically, keeping the main visualization uncluttered. Library/Method: HTML/CSS/JS. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kuva Space</title>

    <!-- Web App Manifest & PWA Tags for Borderless Experience -->
    <link rel="manifest" href='data:application/manifest+json;base64,ewogICJuYW1lIjogIkt1dmEgU3BhY2UiLAogICJzaG9ydF9uYW1lIjogIkt1dmEgU3BhY2UiLAogICJzdGFydF91cmwiOiAiLiIsCiAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgImJhY2tncm91bmRfY29sb3IiOiAiIzAwMDAwMCIsCiAgInRoZW1lX2NvbG9yIjogIiMwMDAwMDAiLCJkZXNjcmlwdGlvbiI6IkFuIGludGVyYWN0aXZlIDNEIHNhdGVsbGl0ZSB0cmFja2VyIGZyb20gS3V2YSBTcGFjZS4iLCJpY29ucyI6W3sic3JjIjoiaHR0cHM6Ly9kYXZla3V2YS5naXRodWIuaW8vU3dhdGgtU2ltL2ltYWdlcy9sb2dvLnBuZyIsInNpemVzIjoiMTkyeDE5MiIsInR5cGUiOiJpbWFnZS9wbmciLCJwdXJwb3NlIjoiYW55IG1hc2thYmxlIn0seyJzcmMiOiJodHRwczovL2RhdmVrdXZhLmdpdGh1Yi5pby9Td2F0aC1TaW0vaW1hZ2VzL2xvZ28ucG5nIiwic2l6ZXMiOiI1MTJ4NTEyIiwidHlwZSI6ImltYWdlL3BuZyIsInB1cnBvc2UiOiJhbnkgbWFza2FibGUifV19'>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Kuva Space">
    <link rel="apple-touch-icon" href="https://davekuva.github.io/kuva-sim/images/logo.png">
    <meta name="theme-color" content="#000000">

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @font-face {
            font-family: 'FKGroteskSemiMono';
            /* Use the direct raw.githubusercontent.com links to avoid CORS redirect issues */
            src: url('https://raw.githubusercontent.com/DaveKuva/kuva-sim/main/Font/FKGroteskSemiMono-Regular.woff2') format('woff2'),
                 url('https://raw.githubusercontent.com/DaveKuva/kuva-sim/fccf470a3e07c1c9c9d873cb7e996fcac0826947/Font/FKGroteskSemiMono-Regular.woff') format('woff');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'FKGroteskSemiMono', sans-serif;
            background-color: #0A0A0A;
            color: #FDFDFD;
            -webkit-tap-highlight-color: transparent;
        }
        canvas {
            display: block;
        }
        #logo {
            position: absolute;
            top: 1rem;
            left: 1rem;
            width: 75px;
            z-index: 9;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }
        .ui-panel {
            position: absolute;
            z-index: 9;
            padding: 1rem;
            background-color: rgba(10, 10, 10, 0.7);
            border-radius: 0.5rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .slide-panel {
            position: absolute;
            top: 0;
            height: 100vh;
            width: 300px; 
            max-width: 85%;
            background-color: rgba(10, 10, 10, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease-in-out;
            z-index: 10;
            display: flex;
            flex-direction: column;
        }
        #satellitePanel {
            left: 0;
            transform: translateX(-100%);
            border-left: none;
            border-top-right-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }
        #satellitePanel.open {
            transform: translateX(0);
        }
        .panel-toggle {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            background-color: rgba(10, 10, 10, 0.8);
            padding: 1.25rem 0.5rem;
            cursor: pointer;
            font-weight: bold;
            letter-spacing: 2px;
            transition: background-color 0.2s;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-right: none;
            text-transform: capitalize;
        }
        .panel-toggle:hover {
             background-color: rgba(30, 30, 30, 0.9);
        }
        #toggleLeftPanelBtn {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            z-index: 5;
            border-radius: 0 0.5rem 0.5rem 0;
            border-left: none;
        }
        .close-panel-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            font-size: 1.5rem;
            line-height: 1;
            color: #9ca3af;
            cursor: pointer;
            transition: color 0.2s;
            padding: 0.5rem;
            width: 44px;
            height: 44px;
            text-align: center;
        }
        .close-panel-btn:hover {
            color: #FDFDFD;
        }
        #focusedSatInfo {
            max-width: calc(100% - 2rem);
        }
        .sat-item {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 0.75rem;
            margin-bottom: 0.75rem;
        }
        .sat-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .sat-item-clickable:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .custom-select {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FDFDFD%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat; background-position: right .7em top 50%; background-size: .65em auto;
        }
        .toggle-switch { position: relative; display: inline-block; width: 50px; height: 24px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #4a5568; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #A5AEAB; }
        input:checked + .slider:before { transform: translateX(26px); }
        .chevron-icon.rotate-180 { transform: rotate(180deg); }
    </style>
</head>
<body>
    <img id="logo" src="https://davekuva.github.io/kuva-sim/images/logo.png" alt="Logo">
    <div id="container"></div>

    <div id="toggleLeftPanelBtn" class="panel-toggle">Control panel</div>

    <div id="satellitePanel" class="slide-panel p-0">
        <div class="p-6 pb-4 flex justify-between items-center flex-shrink-0 relative">
            <h2 class="text-xl font-bold">Control panel</h2>
            <button id="closeLeftPanelBtn" class="close-panel-btn top-4 right-4 text-2xl">&times;</button>
        </div>

        <div class="overflow-y-auto px-6 pb-6">
            <p class="text-sm text-gray-400 mb-4">Tap a satellite to focus on it. Expand the sections below to access more controls.</p>
            <div>
                <button id="toggleSatelliteListBtn" class="w-full text-left font-bold text-md py-2 flex justify-between items-center hover:bg-gray-800 rounded-md px-2">
                    <span>Satellites</span>
                    <svg id="satelliteListChevron" class="w-4 h-4 transition-transform duration-300 chevron-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </button>
                <div id="satelliteListContainer" class="overflow-hidden transition-all duration-300 ease-in-out px-2">
                    <div id="satelliteList" class="space-y-3 pt-2">
                         <p class="text-gray-400">Loading satellites...</p>
                    </div>
                </div>
            </div>

            <div id="constellationControl" class="space-y-3 mt-4 pt-4 border-t border-gray-700">
                <label for="constellationSlider" class="font-bold text-sm">Hyperfield constellation size: <span id="constellationCount">2</span></label>
                <input type="range" id="constellationSlider" min="2" max="100" value="2" class="w-full">
                <button id="trackEarthBtn" class="bg-gray-800 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md transition duration-300 w-full border border-gray-600">Global view</button>
                 <div id="focusControl" class="hidden">
                     <label for="focusSelect" class="font-bold text-sm">Focus target</label>
                     <select id="focusSelect" class="custom-select w-full bg-gray-700 text-white rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-gray-500 mt-1"></select>
                </div>
            </div>
            
             <div class="mt-2 pt-2 border-t border-gray-700">
                <button id="toggleAdvancedVisualsBtn" class="w-full text-left font-bold text-md py-2 flex justify-between items-center hover:bg-gray-800 rounded-md px-2">
                    <span>Advanced settings</span>
                    <svg id="advancedVisualsChevron" class="w-4 h-4 transition-transform duration-300 chevron-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </button>
                <div id="advancedVisualsSection" class="overflow-hidden transition-all duration-300 ease-in-out px-2" style="max-height: 0px;">
                    <div class="py-2">
                        <div class="flex items-center justify-between pt-3"><label for="timeWarpToggle" class="font-bold text-sm text-gray-300">Fast forward (1s=1min)</label><label class="toggle-switch"><input type="checkbox" id="timeWarpToggle"><span class="slider"></span></label></div>
                        <div class="flex items-center justify-between pt-3"><label for="dayNightSwathToggle" class="font-bold text-sm text-gray-300">Day/night swath only</label><label class="toggle-switch"><input type="checkbox" id="dayNightSwathToggle" checked><span class="slider"></span></label></div>
                        <div class="flex items-center justify-between pt-3"><label for="beamsToggle" class="font-bold text-sm text-gray-300">Show satellite beams</label><label class="toggle-switch"><input type="checkbox" id="beamsToggle" checked><span class="slider"></span></label></div>
                        <div class="flex items-center justify-between pt-3"><label for="demoModeToggle" class="font-bold text-sm text-gray-300">Demo Sunlit Pass</label><label class="toggle-switch"><input type="checkbox" id="demoModeToggle"><span class="slider"></span></label></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="focusedSatInfo" class="ui-panel hidden" style="bottom: 1rem; right: 1rem;"></div>

    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec3 vNormal;
        void main() { 
            vNormal = normalize(normalMatrix * normal); 
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); 
        }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
        uniform float uOpacity;
        varying vec3 vNormal;
        void main() { 
            float intensity = pow(0.5 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 1.5); 
            vec4 color = vec4(0.3, 0.6, 1.0, 1.0) * intensity * 1.5;
            gl_FragColor = vec4(color.rgb, color.a * uOpacity);
        }
    </script>
     <script id="cityLightsVertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        varying vec3 vWorldNormal;
        void main() {
            vUv = uv;
            vWorldNormal = normalize(mat3(modelMatrix) * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script id="cityLightsFragmentShader" type="x-shader/x-fragment">
        uniform sampler2D cityTexture;
        uniform vec3 sunDirection;
        varying vec2 vUv;
        varying vec3 vWorldNormal;
        void main() {
            float intensity = dot(vWorldNormal, normalize(sunDirection));
            float night = smoothstep(0.25, -0.25, intensity);
            vec4 texColor = texture2D(cityTexture, vUv);
            gl_FragColor = vec4(texColor.rgb * 1.5, texColor.a * night);
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/satellite.js/4.1.3/satellite.min.js"></script>
    
    <script>
        // Minimal Service Worker to enable PWA installability
        if ('serviceWorker' in navigator) {
            const sw_string = `
                self.addEventListener('fetch', function(event) {
                    // This is enough to trigger the PWA install prompt.
                });
            `;
            const blob = new Blob([sw_string], {type: 'application/javascript'});
            const sw_url = URL.createObjectURL(blob);

            navigator.serviceWorker.register(sw_url)
                .then(function(registration) {
                    console.log('Service Worker registered with scope:', registration.scope);
                })
                .catch(function(error) {
                    console.log('Service Worker registration failed:', error);
                });
        }
    </script>
    
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.128.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';
        import { Line2 } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/lines/Line2.js';
        import { LineMaterial } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/lines/LineMaterial.js';
        import { LineGeometry } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/lines/LineGeometry.js';

        const container = document.getElementById('container');
        const satelliteListDiv = document.getElementById('satelliteList');
        const trackEarthBtn = document.getElementById('trackEarthBtn');
        const focusControl = document.getElementById('focusControl');
        const focusSelect = document.getElementById('focusSelect');
        const satellitePanel = document.getElementById('satellitePanel');
        const toggleLeftPanelBtn = document.getElementById('toggleLeftPanelBtn');
        const closeLeftPanelBtn = document.getElementById('closeLeftPanelBtn');
        const focusedSatInfo = document.getElementById('focusedSatInfo');
        const constellationSlider = document.getElementById('constellationSlider');
        const constellationCount = document.getElementById('constellationCount');
        const timeWarpToggle = document.getElementById('timeWarpToggle');
        const dayNightSwathToggle = document.getElementById('dayNightSwathToggle');
        const beamsToggle = document.getElementById('beamsToggle');
        const toggleAdvancedVisualsBtn = document.getElementById('toggleAdvancedVisualsBtn');
        const advancedVisualsSection = document.getElementById('advancedVisualsSection');
        const advancedVisualsChevron = document.getElementById('advancedVisualsChevron');
        const toggleSatelliteListBtn = document.getElementById('toggleSatelliteListBtn');
        const satelliteListContainer = document.getElementById('satelliteListContainer');
        const satelliteListChevron = document.getElementById('satelliteListChevron');
        const demoModeToggle = document.getElementById('demoModeToggle');
        
        let pressStartTime = 0;
        let startX = 0;
        let startY = 0;
        const MAX_PRESS_DURATION = 200; // ms
        const MAX_MOVE_DISTANCE = 10; // pixels

        let scene, camera, renderer, controls, directionalLight;
        let earth, clouds, atmosphere, cityLights;
        const trackedSatellites = {};
        let cameraMode = 'earth';
        let focusedSatelliteId = null;
        let satColorIndex = 0;
        let clock;
        let simulationTime;
        let isTimeWarping = false;
        let isDemoMode = false;
        let demoTimeOffset = 0;
        const TIME_WARP_FACTOR = 60;
        
        let cameraTransitionState = 'idle';
        let cameraTransitionProgress = 0;
        let transitionDuration = 2.5;
        let transitionStartPosition = new THREE.Vector3();
        let transitionStartTarget = new THREE.Vector3();
        let transitionEndPosition = new THREE.Vector3();
        let transitionEndTarget = new THREE.Vector3();

        let enforceDayNightSwath = true;
        let showBeams = true;

        const EARTH_RADIUS_KM = 6371;
        const SCALING_FACTOR = 1 / 1000;
        const EARTH_RADIUS_SCALED = EARTH_RADIUS_KM * SCALING_FACTOR;
        const SAT_COLORS = [0xff6347, 0x9370db, 0x4682b4, 0x32cd32, 0xffd700, 0x00fa9a, 0xff4500, 0x1e90ff];
        const SWATH_SNAPSHOT_DISTANCE_KM = 45; 
        const DEFAULT_TLES = {
            '60562': ['Hyperfield-1A', '1 60562U 24149CY  25273.14645047  .00015321  00000+0  58728-3 0  9993', '2 60562  97.4049 350.0439 0006684 141.6331 218.5385 15.26583021 62307'],
            '64552': ['Hyperfield-1B', '1 64552U 25135AA  25273.18590572  .00010550  00000+0  50593-3 0  9999', '2 64552  97.4478  26.1903 0002229 109.4879 250.6596 15.19077417 15367']
        };

        function init() {
            clock = new THREE.Clock();
            simulationTime = new Date();
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 15, 30);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxDistance = 150;
            
            setCameraMode('earth'); 
            scene.add(new THREE.AmbientLight(0x111111));
            directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            scene.add(directionalLight);

            createSkybox();
            createEarth();
            
            window.addEventListener('resize', onWindowResize, false);
            trackEarthBtn.addEventListener('click', () => setCameraMode('earth'));
            focusSelect.addEventListener('change', (e) => setFocusedSatellite(e.target.value));

            demoModeToggle.addEventListener('change', (e) => {
                isDemoMode = e.target.checked;
                if (isDemoMode) {
                    const demoSatId = '60562'; // Use Hyperfield-1A for the demo
                    if (trackedSatellites[demoSatId]) {
                        const nextPass = findNextSunlitPass(trackedSatellites[demoSatId].satrec);
                        const demoStartTime = new Date(nextPass.getTime() + 10 * 60 * 1000); // 10 min offset
                        const now = new Date();
                        demoTimeOffset = demoStartTime.getTime() - now.getTime();
                    }
                } else {
                    demoTimeOffset = 0;
                    // When turning off demo mode, also turn off swath recording for all satellites.
                    for (const id in trackedSatellites) {
                        const sat = trackedSatellites[id];
                        if (sat.isSwathRecording) {
                            sat.isSwathRecording = false;
                            clearSwathPath(id);
                        }
                    }
                    updateSatelliteListUI(); // Update UI to reflect the change in toggles
                }
            });

            toggleLeftPanelBtn.addEventListener('click', () => satellitePanel.classList.toggle('open'));
            closeLeftPanelBtn.addEventListener('click', () => satellitePanel.classList.remove('open'));

            container.addEventListener('pointerdown', (e) => {
                pressStartTime = Date.now();
                startX = e.clientX;
                startY = e.clientY;
            });

            container.addEventListener('pointerup', (e) => {
                const pressDuration = Date.now() - pressStartTime;
                const distanceX = Math.abs(e.clientX - startX);
                const distanceY = Math.abs(e.clientY - startY);
                
                if (pressDuration < MAX_PRESS_DURATION && distanceX < MAX_MOVE_DISTANCE && distanceY < MAX_MOVE_DISTANCE) {
                    if (satellitePanel.classList.contains('open')) {
                        satellitePanel.classList.remove('open');
                    }
                }
            });

            constellationSlider.addEventListener('input', (e) => {
                const size = parseInt(e.target.value, 10);
                constellationCount.textContent = size;
                updateConstellation(size);
            });
            
            timeWarpToggle.addEventListener('change', (e) => {
                isTimeWarping = e.target.checked;
                if (!isTimeWarping) {
                    // When time warp is turned off, also turn off swath recording for all satellites.
                    for (const id in trackedSatellites) {
                        const sat = trackedSatellites[id];
                        if (sat.isSwathRecording) {
                            sat.isSwathRecording = false;
                            clearSwathPath(id);
                        }
                    }
                    updateSatelliteListUI(); // Update UI to reflect the change in toggles
                }
            });

            dayNightSwathToggle.addEventListener('change', (e) => { enforceDayNightSwath = e.target.checked; });
            beamsToggle.addEventListener('change', (e) => { showBeams = e.target.checked; });

            toggleAdvancedVisualsBtn.addEventListener('click', () => {
                const isOpen = advancedVisualsSection.style.maxHeight !== '0px';
                advancedVisualsSection.style.maxHeight = isOpen ? '0px' : advancedVisualsSection.scrollHeight + 'px';
                advancedVisualsChevron.classList.toggle('rotate-180', !isOpen);
            });
           
            toggleSatelliteListBtn.addEventListener('click', () => {
                const isOpen = satelliteListContainer.style.maxHeight !== '0px' && satelliteListContainer.style.maxHeight;
                satelliteListContainer.style.maxHeight = isOpen ? '0px' : satelliteListContainer.scrollHeight + 'px';
                satelliteListChevron.classList.toggle('rotate-180');
            });

            satellitePanel.addEventListener('click', (e) => {
                const satItem = e.target.closest('.sat-item-clickable');
                if (satItem && satItem.dataset.id) {
                    const satId = satItem.dataset.id;
                    setCameraMode('satellite');
                    setFocusedSatellite(satId);
                }
            });

            satellitePanel.addEventListener('change', (e) => {
                const satId = e.target.dataset.id;
                if (!satId || !trackedSatellites[satId]) return;
                const sat = trackedSatellites[satId];
                if (e.target.classList.contains('visibility-toggle')) sat.isVisible = e.target.checked;
                else if (e.target.classList.contains('swath-toggle')) sat.isSwathVisible = e.target.checked;
                else if (e.target.classList.contains('record-toggle')) {
                    sat.isSwathRecording = e.target.checked;
                    clearSwathPath(satId);
                }
            });
            
            start();
        }
        
        async function start() {
            setCameraMode('earth');
            await initializeSatellites();
            animate();

            // Set satellite list to be open by default
            satelliteListContainer.style.maxHeight = satelliteListContainer.scrollHeight + 'px';
            satelliteListChevron.classList.add('rotate-180');
        }
        
        function formatSatelliteName(str) {
            if (!str) return '';
            const parts = str.trim().split('-');
            if (parts.length > 1) {
                const baseName = parts[0].charAt(0).toUpperCase() + parts[0].slice(1).toLowerCase();
                const designation = parts.slice(1).join('-').toUpperCase();
                return `${baseName}-${designation}`;
            }
            return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
        }

        async function initializeSatellites() {
            Object.keys(DEFAULT_TLES).forEach(id => addSatellite(id, DEFAULT_TLES[id]));
            focusedSatelliteId = null;
            updateSatelliteListUI();
            await updateAllTLEs();
            setInterval(updateAllTLEs, 3600 * 1000 * 6); // Fetch every 6 hours
        }

        async function updateAllTLEs() {
            console.log("Attempting to update TLEs from CelesTrak...");
            const updateIndicator = document.createElement('p');
            updateIndicator.textContent = 'Updating TLEs...';
            updateIndicator.className = 'text-yellow-400 text-sm p-2 text-center';
            satelliteListDiv.prepend(updateIndicator);

            const tlePromises = Object.keys(trackedSatellites).map(async (noradId) => {
                try {
                    const response = await fetch(`https://celestrak.org/NORAD/elements/gp.php?CATNR=${noradId}&FORMAT=TLE`);
                    if (!response.ok) throw new Error(`HTTP status ${response.status}`);
                    const tleString = await response.text();
                    const tleLines = tleString.trim().split('\r\n');
                    if (tleLines.length < 3) throw new Error('Invalid TLE format received');
                    return { noradId, tleData: [tleLines[0].trim(), tleLines[1].trim(), tleLines[2].trim()], status: 'success' };
                } catch (error) {
                    console.warn(`Failed to fetch TLE for ${noradId}: ${error.message}. Keeping existing data.`);
                    return { noradId, status: 'failed' };
                }
            });

            const results = await Promise.all(tlePromises);
            let needsUiUpdate = false;
            for (const result of results) {
                if (result.status === 'success') {
                    const { noradId, tleData } = result;
                    const sat = trackedSatellites[noradId];
                    const newName = formatSatelliteName(tleData[0]);
                    console.log(`Updating ${noradId} with new TLE for ${newName}`);
                    sat.satrec = satellite.twoline2satrec(tleData[1], tleData[2]);
                    sat.tleName = newName;
                    scene.remove(sat.orbit);
                    sat.orbit = createOrbit(sat.satrec);
                    scene.add(sat.orbit);
                    needsUiUpdate = true;
                }
            }
            if (needsUiUpdate) updateSatelliteListUI();
            updateIndicator.remove();
        }
        
        function createEarth() {
            const textureLoader = new THREE.TextureLoader();
            const earthGeo = new THREE.SphereGeometry(EARTH_RADIUS_SCALED, 32, 32);
            earth = new THREE.Mesh(earthGeo, new THREE.MeshLambertMaterial({ map: textureLoader.load('https://raw.githubusercontent.com/DaveKuva/kuva-sim/main/images/2_no_clouds_4k.jpg') }));
            scene.add(earth);

            const lightsGeo = new THREE.SphereGeometry(EARTH_RADIUS_SCALED * 1.002, 32, 32);
            const lightsMat = new THREE.ShaderMaterial({
                uniforms: {
                    cityTexture: { value: textureLoader.load('https://raw.githubusercontent.com/DaveKuva/kuva-sim/main/images/land_lights_16384.png') },
                    sunDirection: { value: new THREE.Vector3() }
                },
                vertexShader: document.getElementById('cityLightsVertexShader').textContent,
                fragmentShader: document.getElementById('cityLightsFragmentShader').textContent,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthTest: false
            });
            cityLights = new THREE.Mesh(lightsGeo, lightsMat);
            scene.add(cityLights);

            const cloudGeo = new THREE.SphereGeometry(EARTH_RADIUS_SCALED * 1.005, 32, 32);
            clouds = new THREE.Mesh(cloudGeo, new THREE.MeshPhongMaterial({ map: textureLoader.load('https://raw.githubusercontent.com/DaveKuva/kuva-sim/main/images/fair_clouds_4k.png'), transparent: true, opacity: 0.8 }));
            scene.add(clouds);
            const atmoGeo = new THREE.SphereGeometry(EARTH_RADIUS_SCALED * 1.05, 32, 32);
            const atmoMat = new THREE.ShaderMaterial({ 
                uniforms: {
                    uOpacity: { value: 1.0 }
                },
                vertexShader: document.getElementById('vertexShader').textContent, 
                fragmentShader: document.getElementById('fragmentShader').textContent, 
                blending: THREE.AdditiveBlending, 
                side: THREE.BackSide,
                transparent: true,
                depthWrite: false
            });
            atmosphere = new THREE.Mesh(atmoGeo, atmoMat);
            scene.add(atmosphere);
        }

        function createSkybox() {
            const texture = new THREE.TextureLoader().load('https://s3-us-west-2.amazonaws.com/s.cdpn.io/141228/starfield.png');
            const skyGeo = new THREE.SphereGeometry(1000, 32, 32);
            const skyMat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide, color: 0xcccccc });
            scene.add(new THREE.Mesh(skyGeo, skyMat));
        }
        
        function createSwath() {
            const swathSize = 50 * SCALING_FACTOR;
            const swathGeo = new THREE.PlaneGeometry(swathSize, swathSize);
            const swathMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthTest: false });
            const mesh = new THREE.Mesh(swathGeo, swathMat);
            mesh.renderOrder = 1; 
            mesh.visible = false;
            return mesh;
        }

        function getJulianDate(date) { return (date.getTime() / 86400000) + 2440587.5; }

        function calculateAccurateSunPosition(date) {
            const toRad = Math.PI / 180;
            const julianDate = getJulianDate(date);
            const T = (julianDate - 2451545.0) / 36525;
            let L0 = 280.46646 + T * (36000.76983 + T * 0.0003032);
            L0 = L0 % 360;
            let M = 357.52911 + T * (35999.05029 - T * 0.0001537);
            M = M % 360;
            const Mrad = M * toRad;
            const C = (1.914602 - T * (0.004817 + 0.000014 * T)) * Math.sin(Mrad) + (0.019993 - T * 0.000101) * Math.sin(2 * Mrad) + 0.000289 * Math.sin(3 * Mrad);
            const sunTrueLongitude = L0 + C;
            const sunTrueLongitudeRad = sunTrueLongitude * toRad;
            let epsilon = 23 + (26 / 60) + (21.448 / 3600) - T * ((46.8150 / 3600) + T * ((0.00059 / 3600) - T * (0.001813 / 3600)));
            const epsilonRad = epsilon * toRad;
            const sunX = Math.cos(sunTrueLongitudeRad);
            const sunY = Math.sin(sunTrueLongitudeRad) * Math.cos(epsilonRad);
            const sunZ = Math.sin(sunTrueLongitudeRad) * Math.sin(epsilonRad);
            const distanceScale = 100;
            return new THREE.Vector3(sunX * distanceScale, sunZ * distanceScale, -sunY * distanceScale);
        }

        function addSatellite(noradId, tleData) {
            if (!tleData) return;
            const tleName = tleData[0];
            const satrec = satellite.twoline2satrec(tleData[1].trim(), tleData[2].trim());
            const mainSat = createSatelliteInstance(true);
            trackedSatellites[noradId] = { satrec, tleName, color: mainSat.mesh.material.color.getHex(), orbit: createOrbit(satrec), instances: [mainSat], isVisible: true, isSwathVisible: true, isSwathRecording: false };
            scene.add(trackedSatellites[noradId].orbit);
        }

        function createSatelliteInstance(isMain = false) {
             const newColor = isMain ? SAT_COLORS[satColorIndex++ % SAT_COLORS.length] : 0xaaaaaa;
             const baseSize = 0.08, scaleFactor = baseSize / 366; 
             const mainSatSize = { x: 226 * scaleFactor, y: 100 * scaleFactor, z: 366 * scaleFactor };
             const instanceSatSize = { x: mainSatSize.x / 2, y: mainSatSize.y / 2, z: mainSatSize.z / 2 };
             const size = isMain ? mainSatSize : instanceSatSize;
    
             const satGeo = new THREE.BoxGeometry(size.x, size.y, size.z);
             const satMat = new THREE.MeshBasicMaterial({ color: newColor });
             const satMesh = new THREE.Mesh(satGeo, satMat);
             scene.add(satMesh);
             
             const swath = createSwath();
             scene.add(swath);
             
             const swathSize = 50 * SCALING_FACTOR;
             const radiusBottom = swathSize / Math.sqrt(2);
             const beamGeo = new THREE.CylinderGeometry(0.001, radiusBottom, 1, 4, 1);
             beamGeo.rotateY(Math.PI / 4); beamGeo.rotateX(Math.PI / 2); beamGeo.translate(0, 0, 0.5); 
             const beamMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.25, side: THREE.DoubleSide, depthWrite: false, depthTest: false });
             const beam = new THREE.Mesh(beamGeo, beamMat);
             scene.add(beam);
             
             return { mesh: satMesh, swath, beam, swathPath: [], lastSnapshotPosition: new THREE.Vector3(), needsSnapshotReset: true, velocity: { x: 0, y: 0, z: 0 } };
        }

        function updateConstellation(size) {
            ['60562', '64552'].forEach(id => {
                if (trackedSatellites[id]) {
                    for(let i = 1; i < trackedSatellites[id].instances.length; i++) {
                        const instance = trackedSatellites[id].instances[i];
                        scene.remove(instance.mesh); scene.remove(instance.swath); scene.remove(instance.beam);
                        instance.swathPath.forEach(p => earth.remove(p));
                    }
                    trackedSatellites[id].instances.splice(1);
                }
            });
            
            const countA = Math.ceil(size / 2), countB = Math.floor(size / 2);
            for(let i = 1; i < countA; i++) if (trackedSatellites['60562']) trackedSatellites['60562'].instances.push(createSatelliteInstance());
            for(let i = 1; i < countB; i++) if (trackedSatellites['64552']) trackedSatellites['64552'].instances.push(createSatelliteInstance());
        }
        
        function clearSwathPath(noradId) {
            const sat = trackedSatellites[noradId];
            if (sat) sat.instances.forEach(inst => {
                inst.swathPath.forEach(swath => earth.remove(swath));
                inst.swathPath = [];
                inst.needsSnapshotReset = true;
            });
        }

        function createOrbit(satrec) {
            const points = [];
            const orbitalPeriod = (2 * Math.PI) / satrec.no;
            const segments = 1024;
            const epochDate = new Date((satrec.jdsatepoch - 2440587.5) * 86400000);
            for (let i = 0; i <= segments; i++) {
                const time = new Date(epochDate.getTime() + (i / segments) * orbitalPeriod * 60000);
                const positionEci = satellite.propagate(satrec, time).position;
                if (positionEci) points.push(positionEci.x * SCALING_FACTOR, positionEci.z * SCALING_FACTOR, -positionEci.y * SCALING_FACTOR);
            }
            
            const lineGeo = new LineGeometry();
            lineGeo.setPositions(points);
            const lineMat = new LineMaterial({ color: 0xffffff, linewidth: 2, transparent: true, opacity: 0.5, resolution: new THREE.Vector2(window.innerWidth, window.innerHeight) });
            const orbitLine = new Line2(lineGeo, lineMat);
            orbitLine.computeLineDistances();
            return orbitLine;
        }

        function updateSatelliteListUI() {
            satelliteListDiv.innerHTML = '';
            focusSelect.innerHTML = '';
            const placeholder = document.createElement('option');
            placeholder.value = ""; placeholder.textContent = "Select a satellite..."; placeholder.disabled = true;
            focusSelect.appendChild(placeholder);
            const satelliteIds = Object.keys(trackedSatellites);
            if (satelliteIds.length === 0) {
                satelliteListDiv.innerHTML = '<p class="text-gray-400">No satellites tracked.</p>';
                return;
            }
            satelliteIds.forEach(id => {
                const sat = trackedSatellites[id];
                const satElement = document.createElement('div');
                satElement.className = 'sat-item text-sm';
                
                const isHyperfield = sat.tleName.toLowerCase().includes('hyperfield');
                const swathControlsHTML = isHyperfield ? `
                    <div class="mt-2 pt-2 space-y-2">
                        <div class="flex items-center justify-between"><label class="text-sm text-gray-400">Show live swath</label><label class="toggle-switch"><input type="checkbox" class="swath-toggle" data-id="${id}" ${sat.isSwathVisible ? 'checked' : ''}><span class="slider"></span></label></div>
                        <div class="flex items-center justify-between"><label class="text-sm text-gray-400">Record swath path</label><label class="toggle-switch"><input type="checkbox" class="record-toggle" data-id="${id}" ${sat.isSwathRecording ? 'checked' : ''}><span class="slider"></span></label></div>
                    </div>` : '';

                satElement.innerHTML = `<div class="sat-item-clickable p-2 rounded-md transition-colors duration-200 cursor-pointer" data-id="${id}">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-2 pointer-events-none">
                            <span class="w-3 h-3 rounded-full" style="background-color: #${sat.color.toString(16).padStart(6, '0')}; border: 1px solid #1a1a1a;"></span>
                            <strong class="text-base font-medium">${sat.tleName}</strong>
                        </div>
                        <label class="toggle-switch"><input type="checkbox" class="visibility-toggle" data-id="${id}" ${sat.isVisible ? 'checked' : ''}><span class="slider"></span></label>
                    </div>
                    <div class="mt-1 text-gray-300 leading-tight pointer-events-none">
                        <p><strong>NORAD ID:</strong> ${id}</p>
                        <p><strong>Altitude:</strong> <span id="alt-${id}">N/A</span> km</p>
                        <p><strong>Velocity:</strong> <span id="vel-${id}">N/A</span> km/s</p>
                    </div>
                    </div>
                    ${swathControlsHTML}
                `;
                satelliteListDiv.appendChild(satElement);
                const option = document.createElement('option');
                option.value = id; option.textContent = sat.tleName;
                focusSelect.appendChild(option);
            });
            focusSelect.value = focusedSatelliteId || "";
            
            // After populating, if the panel is open, resize it to fit new content.
            const isOpen = satelliteListContainer.style.maxHeight !== '0px' && satelliteListContainer.style.maxHeight;
            if (isOpen) {
                satelliteListContainer.style.maxHeight = satelliteListContainer.scrollHeight + 'px';
            }
        }

        function updateFocusedSatInfoUI() {
             if (cameraMode === 'satellite' && focusedSatelliteId && trackedSatellites[focusedSatelliteId]) {
                const sat = trackedSatellites[focusedSatelliteId];
                if (focusedSatInfo.dataset.currentSat !== focusedSatelliteId) {
                    focusedSatInfo.dataset.currentSat = focusedSatelliteId;
                    focusedSatInfo.innerHTML = `
                        <div class="flex items-center gap-2">
                            <span class="w-3 h-3 rounded-full" style="background-color: #${sat.color.toString(16).padStart(6, '0')}; border: 1px solid #1a1a1a;"></span>
                            <strong class="text-base font-medium">${sat.tleName}</strong>
                        </div>
                        <div class="mt-1 text-gray-300 leading-tight text-sm">
                            <p><strong>NORAD ID:</strong> <span>${focusedSatelliteId}</span></p>
                            <p><strong>Altitude:</strong> <span id="focused-alt">...</span> km</p>
                            <p><strong>Velocity:</strong> <span id="focused-vel">...</span> km/s</p>
                        </div>`;
                }
                focusedSatInfo.classList.remove('hidden');
            } else {
                focusedSatInfo.classList.add('hidden');
                focusedSatInfo.dataset.currentSat = '';
            }
        }
        
        function setCameraMode(mode) {
            cameraMode = mode;
            if (mode === 'earth') {
                trackEarthBtn.classList.replace('bg-gray-800', 'bg-gray-600');
                focusControl.classList.add('hidden');
                constellationControl.classList.remove('hidden');
                if(focusedSatelliteId) setFocusedSatellite("");
            } else {
                 trackEarthBtn.classList.replace('bg-gray-600', 'bg-gray-800');
                 focusControl.classList.remove('hidden');
                 const sat = trackedSatellites[focusedSatelliteId];
                 const isHyperfield = sat && sat.tleName.toLowerCase().includes('hyperfield');
                 constellationControl.classList.toggle('hidden', !isHyperfield);
                 controls.minDistance = 0.1;
            }
            updateFocusedSatInfoUI();
        }
        
        function setFocusedSatellite(noradId) {
            if (!noradId) {
                if (focusedSatelliteId) { 
                    cameraTransitionState = 'toEarth';
                    cameraTransitionProgress = 0;
                    transitionStartPosition.copy(camera.position);
                    transitionStartTarget.copy(controls.target);
                    transitionEndTarget.set(0, 0, 0);
                    transitionEndPosition.set(0, 15, 30);
                }
                
                focusedSatelliteId = null;
                const sat = trackedSatellites[focusedSatelliteId];
                const isHyperfield = sat && sat.tleName.toLowerCase().includes('hyperfield');
                if (cameraMode === 'satellite') constellationControl.classList.toggle('hidden', !isHyperfield);
                if (focusSelect.value != "") focusSelect.value = "";
                updateFocusedSatInfoUI();
                return;
            }

            if (noradId === focusedSatelliteId && cameraTransitionState === 'idle') return;

            focusedSatelliteId = noradId;
            const sat = trackedSatellites[focusedSatelliteId];
            const isHyperfield = sat && sat.tleName.toLowerCase().includes('hyperfield');
            if (cameraMode === 'satellite') constellationControl.classList.toggle('hidden', !isHyperfield);
            if (focusSelect.value != (noradId || "")) focusSelect.value = noradId || "";
            updateFocusedSatInfoUI();
            
            cameraTransitionState = 'toSat';
            cameraTransitionProgress = 0;
            transitionStartPosition.copy(camera.position);
            transitionStartTarget.copy(controls.target);
        }

        function findNextSunlitPass(satrec) {
            const startTime = new Date();
            // Check every 30 seconds for the next ~100 minutes (a full orbit)
            for (let i = 0; i < 200; i++) {
                const checkTime = new Date(startTime.getTime() + i * 30 * 1000);
                const sunPos = calculateAccurateSunPosition(checkTime);
                const posVel = satellite.propagate(satrec, checkTime);
                if (posVel.position) {
                    const satPos = new THREE.Vector3(posVel.position.x, posVel.position.z, -posVel.position.y).normalize();
                    const sunDir = sunPos.clone().normalize();
                    const dotProduct = satPos.dot(sunDir);
                    // A dot product > 0 means the satellite is on the sunlit side
                    if (dotProduct > 0.1) {
                        return checkTime;
                    }
                }
            }
            return startTime; // Fallback
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            
            let satTime;
            const realNow = new Date();

            if (isDemoMode) {
                satTime = new Date(realNow.getTime() + demoTimeOffset);
                if(isTimeWarping) {
                    demoTimeOffset += deltaTime * TIME_WARP_FACTOR * 1000;
                    satTime = new Date(realNow.getTime() + demoTimeOffset);
                }
            } else {
                 if (isTimeWarping) {
                    simulationTime.setMilliseconds(simulationTime.getMilliseconds() + deltaTime * TIME_WARP_FACTOR * 1000);
                    satTime = simulationTime;
                } else {
                    simulationTime = new Date();
                    satTime = simulationTime;
                }
            }

            const gmst = satellite.gstime(realNow);
            
            if(earth) earth.rotation.y = gmst; 
            if(atmosphere) atmosphere.rotation.y = gmst; 
            if(clouds) clouds.rotation.y = gmst * 0.95;
            if(cityLights) cityLights.rotation.y = gmst;
            
            const sunPosition = calculateAccurateSunPosition(satTime);
            directionalLight.position.copy(sunPosition);
            if (cityLights) {
                 cityLights.material.uniforms.sunDirection.value.copy(sunPosition);
            }
            
            for (const id in trackedSatellites) {
                const sat = trackedSatellites[id];
                sat.orbit.visible = sat.isVisible;
                const orbitalPeriod = (2 * Math.PI) / sat.satrec.no * 60000;
                const timeOffset = orbitalPeriod / sat.instances.length;
                const epochDate = new Date((sat.satrec.jdsatepoch - 2440587.5) * 86400000);
                const timeSinceEpoch = satTime.getTime() - epochDate.getTime();

                sat.instances.forEach((instance, index) => {
                    instance.mesh.visible = sat.isVisible;
                    if (!sat.isVisible) {
                        instance.swath.visible = false; instance.beam.visible = false; instance.swathPath.forEach(p => p.visible = false);
                        return;
                    } else {
                         instance.swathPath.forEach(p => p.visible = true);
                    }
                    
                    const instanceTime = new Date(epochDate.getTime() + (timeSinceEpoch + (index * timeOffset)) % orbitalPeriod);
                    const posVel = satellite.propagate(sat.satrec, instanceTime);

                    if (posVel.position && posVel.velocity) {
                        const { position: posEci, velocity: velEci } = posVel;
                        instance.mesh.position.set(posEci.x * SCALING_FACTOR, posEci.z * SCALING_FACTOR, -posEci.y * SCALING_FACTOR);
                        instance.velocity = velEci;
                        
                        const satVelocityVector = new THREE.Vector3(instance.velocity.x, instance.velocity.z, -instance.velocity.y).normalize();
                        instance.mesh.up.copy(satVelocityVector);
                        instance.mesh.lookAt(earth.position);

                        if (index === 0) {
                            const posGd = satellite.eciToGeodetic(posEci, gmst);
                            const altitude = posGd.height;
                            const velocity = Math.sqrt(velEci.x**2 + velEci.y**2 + velEci.z**2);
                            const altEl = document.getElementById(`alt-${id}`), velEl = document.getElementById(`vel-${id}`);
                            if (altEl) altEl.textContent = altitude.toFixed(2);
                            if (velEl) velEl.textContent = velocity.toFixed(2);
                            if (id === focusedSatelliteId && !focusedSatInfo.classList.contains('hidden')) {
                                const focusedAltEl = document.getElementById('focused-alt'), focusedVelEl = document.getElementById('focused-vel');
                                if(focusedAltEl) focusedAltEl.textContent = altitude.toFixed(2);
                                if(focusedVelEl) focusedVelEl.textContent = velocity.toFixed(2);
                            }
                        }

                        const isHyperfield = sat.tleName.toLowerCase().includes('hyperfield');
                        const isDaySide = instance.mesh.position.clone().normalize().dot(sunPosition.clone().normalize()) > 0.1;
                        const swathShouldBeVisible = (enforceDayNightSwath ? isDaySide : true) && isHyperfield && sat.isSwathVisible;
                        instance.swath.visible = swathShouldBeVisible;
                        instance.beam.visible = swathShouldBeVisible && showBeams;
                        
                        if (swathShouldBeVisible) {
                            const surfacePosition = instance.mesh.position.clone().normalize().multiplyScalar(EARTH_RADIUS_SCALED * 1.0005);
                            instance.swath.position.copy(surfacePosition);
                            const satVelVec = new THREE.Vector3(instance.velocity.x, instance.velocity.z, -instance.velocity.y).normalize();
                            instance.swath.up.copy(satVelVec);
                            instance.swath.lookAt(earth.position);
                            instance.beam.position.copy(surfacePosition);
                            instance.beam.up.copy(satVelVec);
                            instance.beam.lookAt(instance.mesh.position);
                            instance.beam.scale.z = surfacePosition.distanceTo(instance.mesh.position);

                            if (sat.isSwathRecording) {
                                const createAndPlaceSnapshot = (position3D) => {
                                    const isSnapshotDaySide = position3D.clone().normalize().dot(sunPosition.clone().normalize()) > 0.1;
                                    if (!enforceDayNightSwath || isSnapshotDaySide) {
                                        const snapshot = createSwath();
                                        snapshot.visible = true;
                                        snapshot.position.copy(position3D.clone().normalize().multiplyScalar(EARTH_RADIUS_SCALED * 1.0005));
                                        const satVelocityVector = new THREE.Vector3(instance.velocity.x, instance.velocity.z, -instance.velocity.y).normalize();
                                        snapshot.up.copy(satVelocityVector);
                                        snapshot.lookAt(earth.position);
                                        snapshot.material.color.setHex((instance.swathPath.length % 2 === 0) ? 0xffff00 : 0xffa500);
                                        earth.worldToLocal(snapshot.position);
                                        snapshot.quaternion.premultiply(earth.quaternion.clone().invert());
                                        earth.add(snapshot);
                                        instance.swathPath.push(snapshot);
                                    }
                                };
                                
                                if (instance.needsSnapshotReset) {
                                    createAndPlaceSnapshot(instance.mesh.position);
                                    instance.lastSnapshotPosition.copy(instance.mesh.position);
                                    instance.needsSnapshotReset = false;
                                }
                                const snapshotDistance = SWATH_SNAPSHOT_DISTANCE_KM * SCALING_FACTOR;
                                while (instance.mesh.position.distanceTo(instance.lastSnapshotPosition) > snapshotDistance) {
                                    const direction = instance.mesh.position.clone().sub(instance.lastSnapshotPosition).normalize();
                                    const nextSnapshotPosition = instance.lastSnapshotPosition.clone().add(direction.multiplyScalar(snapshotDistance));
                                    createAndPlaceSnapshot(nextSnapshotPosition);
                                    instance.lastSnapshotPosition.copy(nextSnapshotPosition);
                                }
                            }
                        }
                    }
                });
            }
            handleCamera(deltaTime);
            controls.update();

            // Smoothly fade out atmosphere when camera is close to prevent visual artifacts
            if (atmosphere && atmosphere.material.uniforms.uOpacity) {
                const startFadeDistance = EARTH_RADIUS_SCALED * 2.5;
                const endFadeDistance = EARTH_RADIUS_SCALED * 1.1;
                const camDistance = camera.position.length();

                const smoothstep = (min, max, value) => {
                    const x = Math.max(0, Math.min(1, (value - min) / (max - min)));
                    return x * x * (3 - 2 * x);
                };

                const opacity = smoothstep(endFadeDistance, startFadeDistance, camDistance);
                atmosphere.material.uniforms.uOpacity.value = opacity;
            }

            if (camera.position.length() < EARTH_RADIUS_SCALED * 1.05) camera.position.setLength(EARTH_RADIUS_SCALED * 1.05);
            
            renderer.render(scene, camera);
        }

        function easeInOutCubic(x) { return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2; }

        function handleCamera(deltaTime) {
            if (cameraTransitionState === 'idle') {
                if (cameraMode === 'satellite' && focusedSatelliteId && trackedSatellites[focusedSatelliteId]) {
                    controls.target.copy(trackedSatellites[focusedSatelliteId].instances[0].mesh.position);
                }
                return; 
            }
            cameraTransitionProgress += deltaTime;
            let alpha = easeInOutCubic(Math.min(cameraTransitionProgress / transitionDuration, 1.0));
            if (cameraTransitionState === 'toSat') {
                if (!focusedSatelliteId || !trackedSatellites[focusedSatelliteId]) { cameraTransitionState = 'idle'; return; }
                const sat = trackedSatellites[focusedSatelliteId].instances[0];
                transitionEndTarget.copy(sat.mesh.position);

                // New logic: Position camera behind and at a slight angle to the satellite
                const direction = sat.mesh.position.clone().normalize();
                const behindVector = direction.clone().multiplyScalar(2.5); // How far behind

                // Get a stable 'side' vector perpendicular to the satellite's position and world 'up'
                const worldUp = new THREE.Vector3(0, 1, 0);
                const sideVector = new THREE.Vector3().crossVectors(direction, worldUp).normalize().multiplyScalar(1.0); // How far to the side

                transitionEndPosition.copy(sat.mesh.position)
                    .add(behindVector)
                    .add(sideVector);

                camera.position.copy(transitionStartPosition).lerp(transitionEndPosition, alpha);
                controls.target.copy(transitionStartTarget).lerp(transitionEndTarget, alpha);
            } else if (cameraTransitionState === 'toEarth') {
                camera.position.copy(transitionStartPosition).lerp(transitionEndPosition, alpha);
                controls.target.copy(transitionStartTarget).lerp(transitionEndTarget, alpha);
            }
            if (alpha >= 1.0) {
                if(cameraTransitionState === 'toSat') controls.target.copy(trackedSatellites[focusedSatelliteId].instances[0].mesh.position);
                else if (cameraTransitionState === 'toEarth') controls.target.set(0,0,0);
                cameraTransitionState = 'idle';
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            Object.values(trackedSatellites).forEach(sat => {
                if (sat.orbit && sat.orbit.material.isLineMaterial) {
                    sat.orbit.material.resolution.set(window.innerWidth, window.innerHeight);
                }
            });
        }
        init();
    </script>
</body>
</html>



