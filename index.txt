<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Satellite Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #000000;
            color: white;
        }
        canvas {
            display: block;
        }
        #logo {
            position: absolute;
            top: 1rem;
            left: 1rem;
            width: 75px;
            z-index: 9;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }
        .ui-panel {
            position: absolute;
            z-index: 9;
            padding: 1rem;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 0.5rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .slide-panel {
            position: absolute;
            top: 0;
            height: 100vh;
            width: 320px; 
            max-width: 90%;
            padding: 1.5rem;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease-in-out;
            z-index: 10;
            display: flex;
            flex-direction: column;
        }
        #satellitePanel {
            left: 0;
            transform: translateX(-100%);
            border-left: none;
            border-top-right-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }
        #satellitePanel.open {
            transform: translateX(0);
        }
        #cameraPanel {
            right: 0;
            transform: translateX(100%);
            border-right: none;
            border-top-left-radius: 0.5rem;
            border-bottom-left-radius: 0.5rem;
        }
        #cameraPanel.open {
            transform: translateX(0);
        }
        .panel-toggle {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            writing-mode: vertical-rl;
            text-orientation: mixed;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 1rem 0.5rem;
            border-radius: 0 0.5rem 0.5rem 0;
            cursor: pointer;
            z-index: 5;
            font-weight: bold;
            letter-spacing: 2px;
            transition: background-color 0.2s;
        }
        .panel-toggle:hover {
             background-color: rgba(30, 30, 30, 0.9);
        }
        #toggleLeftPanelBtn {
            left: 0;
        }
        #toggleRightPanelBtn {
            right: 0;
            border-radius: 0.5rem 0 0 0.5rem;
        }
        .close-panel-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            font-size: 1.5rem;
            line-height: 1;
            color: #9ca3af;
            cursor: pointer;
            transition: color 0.2s;
            padding: 0.5rem;
            width: 44px;
            height: 44px;
            text-align: center;
        }
        .close-panel-btn:hover {
            color: #ffffff;
        }
        #focusedSatInfo {
            max-width: calc(100% - 2rem);
        }
        .sat-item {
            position: relative;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .custom-select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right .7em top 50%;
            background-size: .65em auto;
        }
        /* Toggle Switch CSS */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #4a5568;
            transition: .4s;
            border-radius: 24px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #2563eb;
        }
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        #advancedControlsChevron.rotate-180 {
            transform: rotate(180deg);
        }
        /* Mobile-specific styles */
        @media (max-width: 768px) {
            .panel-toggle {
                padding: 1.5rem 0.75rem;
                font-size: 1.1rem;
            }
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body>
    <img id="logo" src="https://davekuva.github.io/Swath-Sim/images/logo.png" alt="Logo">
    <!-- Canvas for 3D rendering -->
    <div id="container"></div>

    <!-- Toggle Buttons -->
    <div id="toggleLeftPanelBtn" class="panel-toggle">SATELLITES</div>
    <div id="toggleRightPanelBtn" class="panel-toggle">CONTROLS</div>

    <!-- Left Slide Panel -->
    <div id="satellitePanel" class="slide-panel">
        <button id="closeLeftPanelBtn" class="close-panel-btn">&times;</button>
        <h2 class="text-xl font-bold mb-4 flex-shrink-0">Tracked Satellites</h2>
        <div id="satelliteList" class="space-y-2 flex-grow overflow-y-auto">
             <p class="text-gray-400">Loading satellites...</p>
        </div>
    </div>
    
    <!-- Right Slide Panel -->
    <div id="cameraPanel" class="slide-panel">
        <button id="closeRightPanelBtn" class="close-panel-btn">&times;</button>
        <h2 class="text-xl font-bold mb-4 flex-shrink-0">Controls</h2>
        <div class="flex flex-col justify-between flex-grow">
            <!-- Main controls group -->
            <div class="flex flex-col gap-4">
                <div>
                    <label class="font-bold text-sm">Camera Mode</label>
                    <div class="flex gap-2 mt-1">
                         <button id="trackEarthBtn" class="bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded-md transition duration-300 w-full">Earth</button>
                         <button id="trackSatelliteBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md transition duration-300 w-full">Satellite</button>
                    </div>
                </div>
                <div id="focusControl" class="hidden">
                     <label for="focusSelect" class="font-bold text-sm">Focus</label>
                     <select id="focusSelect" class="custom-select w-full bg-gray-700 text-white rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 mt-1"></select>
                </div>
                 <div id="constellationControl" class="space-y-2">
                    <label for="constellationSlider" class="font-bold text-sm">Hyperfield Constellation Size: <span id="constellationCount">2</span></label>
                    <input type="range" id="constellationSlider" min="2" max="100" value="2" class="w-full">
                </div>
            </div>

            <!-- Container for advanced section accordion -->
            <div class="flex flex-col mt-4 pt-4 border-t border-gray-700">
                <button id="toggleAdvancedControlsBtn" class="w-full text-left font-bold text-sm py-2 rounded-md hover:bg-gray-800 transition-colors duration-200 flex justify-between items-center">
                    <span>Advanced Controls</span>
                    <svg id="advancedControlsChevron" class="w-4 h-4 transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </button>

                <div id="advancedControls" class="overflow-hidden transition-all duration-300 ease-in-out" style="max-height: 0px;">
                    <div class="flex items-center justify-between pt-3 mt-2">
                        <label for="timeWarpToggle" class="font-bold text-sm text-gray-300">Fast Forward (1s = 1min)</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="timeWarpToggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="flex items-center justify-between pt-3">
                        <label for="dayNightSwathToggle" class="font-bold text-sm text-gray-300">Day/Night Swath</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="dayNightSwathToggle" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="flex items-center justify-between pt-3">
                        <label for="beamsToggle" class="font-bold text-sm text-gray-300">Show Satellite Beams</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="beamsToggle" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Focused Satellite Info Panel -->
    <div id="focusedSatInfo" class="ui-panel hidden" style="bottom: 1rem; left: 1rem;">
        <!-- Content dynamically populated by JS -->
    </div>

    <!-- Shaders and Libraries -->
    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec3 vNormal;
        void main() { vNormal = normalize(normalMatrix * normal); gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
        varying vec3 vNormal;
        void main() { float intensity = pow(0.6 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0); gl_FragColor = vec4(0.3, 0.6, 1.0, 1.0) * intensity; }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/satellite.js/4.1.3/satellite.min.js"></script>
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.128.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';
        import { Line2 } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/lines/Line2.js';
        import { LineMaterial } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/lines/LineMaterial.js';
        import { LineGeometry } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/lines/LineGeometry.js';

        // --- DOM Elements ---
        const container = document.getElementById('container');
        const satelliteListDiv = document.getElementById('satelliteList');
        const trackEarthBtn = document.getElementById('trackEarthBtn');
        const trackSatelliteBtn = document.getElementById('trackSatelliteBtn');
        const focusControl = document.getElementById('focusControl');
        const focusSelect = document.getElementById('focusSelect');
        const satellitePanel = document.getElementById('satellitePanel');
        const cameraPanel = document.getElementById('cameraPanel');
        const toggleLeftPanelBtn = document.getElementById('toggleLeftPanelBtn');
        const toggleRightPanelBtn = document.getElementById('toggleRightPanelBtn');
        const closeLeftPanelBtn = document.getElementById('closeLeftPanelBtn');
        const closeRightPanelBtn = document.getElementById('closeRightPanelBtn');
        const focusedSatInfo = document.getElementById('focusedSatInfo');
        const constellationControl = document.getElementById('constellationControl');
        const constellationSlider = document.getElementById('constellationSlider');
        const constellationCount = document.getElementById('constellationCount');
        const timeWarpToggle = document.getElementById('timeWarpToggle');
        const toggleAdvancedControlsBtn = document.getElementById('toggleAdvancedControlsBtn');
        const advancedControls = document.getElementById('advancedControls');
        const advancedControlsChevron = document.getElementById('advancedControlsChevron');
        const dayNightSwathToggle = document.getElementById('dayNightSwathToggle');
        const beamsToggle = document.getElementById('beamsToggle');


        // --- Global Variables ---
        let scene, camera, renderer, controls, directionalLight;
        let earth, clouds, atmosphere;
        const trackedSatellites = {};
        let cameraMode = 'earth';
        let focusedSatelliteId = null;
        let satColorIndex = 0;
        let clock;
        let simulationTime;
        let isTimeWarping = false;
        const TIME_WARP_FACTOR = 60;
        const isMobile = window.matchMedia("(max-width: 768px)").matches;
        
        let cameraTransitionState = 'idle';
        let cameraTransitionProgress = 0;
        let transitionDuration = 2.5;
        let transitionStartPosition = new THREE.Vector3();
        let transitionStartTarget = new THREE.Vector3();
        let transitionEndPosition = new THREE.Vector3();
        let transitionEndTarget = new THREE.Vector3();
        let enforceDayNightSwath = true;
        let showBeams = true;

        // --- Constants ---
        const EARTH_RADIUS_KM = 6371;
        const SCALING_FACTOR = 1 / 1000;
        const EARTH_RADIUS_SCALED = EARTH_RADIUS_KM * SCALING_FACTOR;
        const SAT_COLORS = [0xff6347, 0x9370db, 0x4682b4, 0x32cd32, 0xffd700, 0x00fa9a, 0xff4500, 0x1e90ff];
        const SWATH_SNAPSHOT_DISTANCE_KM = 45; 

        const DEFAULT_TLES = {
            '60562': [
                'HYPERFIELD-1A',
                '1 60562U 24149CY  25273.14645047  .00015321  00000+0  58728-3 0  9993',
                '2 60562  97.4049 350.0439 0006684 141.6331 218.5385 15.26583021 62307'
            ],
            '64552': [
                'HYPERFIELD-1B',
                '1 64552U 25135AA  25273.18590572  .00010550  00000+0  50593-3 0  9999',
                '2 64552  97.4478  26.1903 0002229 109.4879 250.6596 15.19077417 15367'
            ]
        };

        function init() {
            clock = new THREE.Clock();
            simulationTime = new Date();

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 15, 30);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxDistance = 150;
            
            setCameraMode('earth'); 

            const ambientLight = new THREE.AmbientLight(0x222222);
            scene.add(ambientLight);
            directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            scene.add(directionalLight);

            createSkybox();
            createEarth();
            
            // --- Event Listeners ---
            window.addEventListener('resize', onWindowResize, false);
            trackEarthBtn.addEventListener('click', () => setCameraMode('earth'));
            trackSatelliteBtn.addEventListener('click', () => setCameraMode('satellite'));
            focusSelect.addEventListener('change', (e) => setFocusedSatellite(e.target.value));

            // Mobile-friendly touch events
            const toggleLeft = () => satellitePanel.classList.toggle('open');
            const toggleRight = () => cameraPanel.classList.toggle('open');
            toggleLeftPanelBtn.addEventListener('click', toggleLeft);
            toggleLeftPanelBtn.addEventListener('touchstart', toggleLeft);
            toggleRightPanelBtn.addEventListener('click', toggleRight);
            toggleRightPanelBtn.addEventListener('touchstart', toggleRight);
            
            closeLeftPanelBtn.addEventListener('click', () => satellitePanel.classList.remove('open'));
            closeRightPanelBtn.addEventListener('click', () => cameraPanel.classList.remove('open'));
            
            constellationSlider.addEventListener('input', (e) => {
                const size = parseInt(e.target.value, 10);
                constellationCount.textContent = size;
                updateConstellation(size);
            });
            
            timeWarpToggle.addEventListener('change', (e) => {
                isTimeWarping = e.target.checked;
                if (!isTimeWarping) { // When fast forward is turned OFF
                    for (const id in trackedSatellites) {
                        const sat = trackedSatellites[id];
                        if (sat.isSwathRecording) {
                            clearSwathPath(id);
                            sat.isSwathRecording = false; // Reset the state
                        }
                    }
                    updateSatelliteListUI(); // Refresh UI to show toggles are off
                }
            });

            dayNightSwathToggle.addEventListener('change', (e) => {
                enforceDayNightSwath = e.target.checked;
            });
            
            beamsToggle.addEventListener('change', (e) => {
                showBeams = e.target.checked;
            });

            toggleAdvancedControlsBtn.addEventListener('click', () => {
                const isOpen = advancedControls.style.maxHeight !== '0px';
                if (isOpen) {
                    advancedControls.style.maxHeight = '0px';
                    advancedControlsChevron.classList.remove('rotate-180');
                } else {
                    advancedControls.style.maxHeight = advancedControls.scrollHeight + 'px';
                    advancedControlsChevron.classList.add('rotate-180');
                }
            });
           
            satellitePanel.addEventListener('change', (e) => {
                const satId = e.target.dataset.id;
                if (!satId || !trackedSatellites[satId]) return;

                const sat = trackedSatellites[satId];
                if (e.target.classList.contains('visibility-toggle')) {
                    sat.isVisible = e.target.checked;
                } else if (e.target.classList.contains('swath-toggle')) {
                    sat.isSwathVisible = e.target.checked;
                } else if (e.target.classList.contains('record-toggle')) {
                    sat.isSwathRecording = e.target.checked;
                    // Always clear the path when the state changes.
                    // This ensures a clean start when toggling on, and cleanup when toggling off.
                    clearSwathPath(satId);
                }
            });

            start();
        }
        
        async function start() {
            setCameraMode('earth');
            await initializeSatellites();
            animate();
        }

        async function initializeSatellites() {
            for (const id in DEFAULT_TLES) {
                addSatellite(id, DEFAULT_TLES[id]);
            }
            focusedSatelliteId = null;
            updateSatelliteListUI();
            await updateAllTLEs();
            setInterval(updateAllTLEs, 3600 * 1000);
        }

        async function updateAllTLEs() {
            console.log("Attempting to update TLEs from CelesTrak...");
            
            const updateIndicator = document.createElement('p');
            updateIndicator.textContent = 'Updating TLEs...';
            updateIndicator.className = 'text-yellow-400 text-sm p-2 text-center';
            satelliteListDiv.prepend(updateIndicator);

            const tlePromises = Object.keys(trackedSatellites).map(async (noradId) => {
                try {
                    const response = await fetch(`https://celestrak.org/NORAD/elements/gp.php?CATNR=${noradId}&FORMAT=TLE`);
                    if (!response.ok) throw new Error(`HTTP status ${response.status}`);
                    const tleString = await response.text();
                    const tleLines = tleString.trim().split('\r\n');
                    if (tleLines.length < 3) throw new Error('Invalid TLE format received');

                    return {
                        noradId,
                        tleData: [tleLines[0].trim(), tleLines[1].trim(), tleLines[2].trim()],
                        status: 'success'
                    };
                } catch (error) {
                    console.warn(`Failed to fetch TLE for ${noradId}: ${error.message}. Keeping existing data.`);
                    return { noradId, status: 'failed' };
                }
            });

            const results = await Promise.all(tlePromises);

            let needsUiUpdate = false;
            for (const result of results) {
                if (result.status === 'success') {
                    const { noradId, tleData } = result;
                    const sat = trackedSatellites[noradId];
                    
                    console.log(`Updating ${noradId} with new TLE for ${tleData[0]}`);

                    sat.satrec = satellite.twoline2satrec(tleData[1], tleData[2]);
                    sat.tleName = tleData[0];
                    
                    scene.remove(sat.orbit);
                    sat.orbit = createOrbit(sat.satrec);
                    scene.add(sat.orbit);
                    
                    needsUiUpdate = true;
                }
            }

            if (needsUiUpdate) {
                updateSatelliteListUI();
            }

            updateIndicator.remove();
        }
        
        function createEarth() {
            const textureLoader = new THREE.TextureLoader();
            const earthGeometry = new THREE.SphereGeometry(EARTH_RADIUS_SCALED, 32, 32);
            const earthMaterial = new THREE.MeshLambertMaterial({
                map: textureLoader.load('https://raw.githubusercontent.com/turban/webgl-earth/master/images/2_no_clouds_4k.jpg'),
            });
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            scene.add(earth);

            const cloudGeometry = new THREE.SphereGeometry(EARTH_RADIUS_SCALED * 1.005, 32, 32);
            const cloudMaterial = new THREE.MeshPhongMaterial({
                map: textureLoader.load('https://raw.githubusercontent.com/turban/webgl-earth/master/images/fair_clouds_4k.png'),
                transparent: true,
                opacity: 0.8
            });
            clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
            scene.add(clouds);

            const atmosphereGeometry = new THREE.SphereGeometry(EARTH_RADIUS_SCALED * 1.02, 32, 32);
            const atmosphereMaterial = new THREE.ShaderMaterial({
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide
            });
            atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            scene.add(atmosphere);
        }

        function createSkybox() {
            const loader = new THREE.TextureLoader();
            const texture = loader.load('https://s3-us-west-2.amazonaws.com/s.cdpn.io/141228/starfield.png');

            const skyboxGeometry = new THREE.SphereGeometry(1000, 32, 32);
            const skyboxMaterial = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.BackSide,
                color: 0x5f5f5f 
            });
            const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
            scene.add(skybox);
        }
        
        function createSwath() {
            const swathSize = 50 * SCALING_FACTOR;
            const swathGeometry = new THREE.PlaneGeometry(swathSize, swathSize);
            const swathMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.4,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthTest: false 
            });
            const mesh = new THREE.Mesh(swathGeometry, swathMaterial);
            mesh.renderOrder = 1; 
            mesh.visible = false;
            return mesh;
        }

        function getJulianDate(date) {
            return (date.getTime() / 86400000) + 2440587.5;
        }

        function calculateSunPosition(date) {
            const julianDate = getJulianDate(date);
            const d = julianDate - 2451545.0;
            const meanLongitude = (280.460 + 0.9856474 * d) % 360;
            const meanAnomaly = (357.528 + 0.9856003 * d) % 360;
            const eclipticLongitude = meanLongitude + 1.915 * Math.sin(meanAnomaly * Math.PI / 180) + 0.020 * Math.sin(2 * meanAnomaly * Math.PI / 180);
            const obliquity = (23.439 - 0.0000004 * d) * Math.PI / 180;
            const lonRad = eclipticLongitude * Math.PI / 180;
            const sunX = Math.cos(lonRad);
            const sunY = Math.sin(lonRad) * Math.cos(obliquity);
            const sunZ = Math.sin(lonRad) * Math.sin(obliquity);
            const distance = 100;
            return new THREE.Vector3(sunX * distance, sunY * distance, sunZ * distance);
        }

        function addSatellite(noradId, tleData) {
            if (!tleData) return;

            const tleName = tleData[0];
            const satrec = satellite.twoline2satrec(tleData[1], tleData[2]);
            
            const mainSat = createSatelliteInstance(true);

            trackedSatellites[noradId] = { 
                satrec, 
                tleName, 
                color: mainSat.mesh.material.color.getHex(),
                orbit: createOrbit(satrec),
                instances: [mainSat],
                isVisible: true,
                isSwathVisible: false,
                isSwathRecording: false
            };
            
            scene.add(trackedSatellites[noradId].orbit);
        }

        function createSatelliteInstance(isMain = false) {
             const newColor = isMain ? SAT_COLORS[satColorIndex++ % SAT_COLORS.length] : 0xaaaaaa;
             // EDIT: Scaled dimensions to real-world proportions
             const baseSize = 0.08; // This is the visual size of the longest dimension
             const scaleFactor = baseSize / 366; 
             const mainSatSize = { x: 226 * scaleFactor, y: 100 * scaleFactor, z: 366 * scaleFactor };
             const instanceSatSize = { x: mainSatSize.x / 2, y: mainSatSize.y / 2, z: mainSatSize.z / 2 };
             const size = isMain ? mainSatSize : instanceSatSize;
    
             const satGeometry = new THREE.BoxGeometry(size.x, size.y, size.z);
             const satMaterial = new THREE.MeshBasicMaterial({ color: newColor });
             const satMesh = new THREE.Mesh(satGeometry, satMaterial);
             
             scene.add(satMesh);
             const swath = createSwath();
             scene.add(swath);
             
             // Create beam
             const swathSize = 50 * SCALING_FACTOR;
             // Create a 4-sided pyramid (cone) that will act as the tapered beam.
             const radiusBottom = swathSize / Math.sqrt(2); // Calculate radius for an inscribed square
             const beamGeometry = new THREE.CylinderGeometry(
                0.001, // radiusTop (the tapered end)
                radiusBottom, // radiusBottom (the wide end)
                1, // height (will be scaled)
                4, // radialSegments (for a square base)
                1
             );
             beamGeometry.rotateY(Math.PI / 4); // Align the square base with the axes.
             beamGeometry.rotateX(Math.PI / 2); // Point the length of the pyramid along the Z-axis.
             beamGeometry.translate(0, 0, 0.5); // Move the origin to the center of the base.
             const beamMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.25,
                side: THREE.DoubleSide,
                depthWrite: false,
                depthTest: false
             });
             const beam = new THREE.Mesh(beamGeometry, beamMaterial);
             scene.add(beam);

             return {
                mesh: satMesh,
                swath: swath,
                beam: beam,
                swathPath: [],
                lastSnapshotPosition: new THREE.Vector3(),
                needsSnapshotReset: true, // Initialize the reset flag
                velocity: { x: 0, y: 0, z: 0 }
            };
        }

        function updateConstellation(size) {
            const hyperfieldIds = ['60562', '64552'];
            
            hyperfieldIds.forEach(id => {
                if (trackedSatellites[id]) {
                    for(let i = 1; i < trackedSatellites[id].instances.length; i++) {
                        const instance = trackedSatellites[id].instances[i];
                        scene.remove(instance.mesh);
                        scene.remove(instance.swath);
                        scene.remove(instance.beam);
                        instance.swathPath.forEach(p => earth.remove(p));
                    }
                    trackedSatellites[id].instances.splice(1);
                }
            });
            
            const countA = Math.ceil(size / 2);
            const countB = Math.floor(size / 2);

            for(let i = 1; i < countA; i++) {
                if (trackedSatellites['60562']) {
                    trackedSatellites['60562'].instances.push(createSatelliteInstance());
                }
            }
            for(let i = 1; i < countB; i++) {
                 if (trackedSatellites['64552']) {
                    trackedSatellites['64552'].instances.push(createSatelliteInstance());
                }
            }
        }
        
        function clearSwathPath(noradId) {
            const sat = trackedSatellites[noradId];
            if (sat) {
                sat.instances.forEach(inst => {
                    inst.swathPath.forEach(swath => earth.remove(swath));
                    inst.swathPath = [];
                    inst.needsSnapshotReset = true; // Set the flag to reset position
                });
            }
        }

        function createOrbit(satrec) {
            const points = [];
            const orbitalPeriod = (2 * Math.PI) / satrec.no;
            const segments = isMobile ? 512 : 1024;
            const epochDate = new Date((satrec.jdsatepoch - 2440587.5) * 86400000);

            for (let i = 0; i <= segments; i++) {
                const time = new Date(epochDate.getTime() + (i / segments) * orbitalPeriod * 60000);
                const positionEci = satellite.propagate(satrec, time).position;
                if (positionEci) {
                    points.push(
                        positionEci.x * SCALING_FACTOR, 
                        positionEci.z * SCALING_FACTOR, 
                        -positionEci.y * SCALING_FACTOR
                    );
                }
            }
            
            const lineGeometry = new LineGeometry();
            lineGeometry.setPositions(points);

            const lineMaterial = new LineMaterial({
                color: 0xffffff,
                linewidth: isMobile ? 3 : 2, // Thicker on mobile
                transparent: true,
                opacity: 0.5,
                resolution: new THREE.Vector2(window.innerWidth, window.innerHeight)
            });

            const orbitLine = new Line2(lineGeometry, lineMaterial);
            orbitLine.computeLineDistances();
            
            return orbitLine;
        }

        function updateSatelliteListUI() {
            satelliteListDiv.innerHTML = '';
            focusSelect.innerHTML = '';

            const placeholder = document.createElement('option');
            placeholder.value = "";
            placeholder.textContent = "Select a satellite...";
            placeholder.disabled = true;
            focusSelect.appendChild(placeholder);

            const satelliteIds = Object.keys(trackedSatellites);
            if (satelliteIds.length === 0) {
                satelliteListDiv.innerHTML = '<p class="text-gray-400">No satellites tracked.</p>';
                return;
            }

            satelliteIds.forEach(id => {
                const sat = trackedSatellites[id];
                const satElement = document.createElement('div');
                satElement.className = 'sat-item text-sm';
                
                let swathControlsHTML = '';
                const isHyperfield = sat.tleName.toUpperCase().includes('HYPERFIELD');
                if (isHyperfield) {
                    swathControlsHTML = `
                        <div class="mt-2 pt-2 border-t border-gray-700 space-y-2">
                            <div class="flex items-center justify-between">
                                <label class="text-sm text-gray-400">Show Live Swath</label>
                                <label class="toggle-switch">
                                    <input type="checkbox" class="swath-toggle" data-id="${id}" ${sat.isSwathVisible ? 'checked' : ''}>
                                    <span class="slider"></span>
                                </label>
                            </div>
                             <div class="flex items-center justify-between">
                                <label class="text-sm text-gray-400">Record Swath Path</label>
                                <label class="toggle-switch">
                                    <input type="checkbox" class="record-toggle" data-id="${id}" ${sat.isSwathRecording ? 'checked' : ''}>
                                    <span class="slider"></span>
                                </label>
                            </div>
                        </div>
                    `;
                }

                satElement.innerHTML = `
                    <div>
                        <div class="flex items-center justify-between">
                             <div class="flex items-center gap-2">
                                <span class="w-3 h-3 rounded-full" style="background-color: #${sat.color.toString(16).padStart(6, '0')}; border: 1px solid #1a1a1a;"></span>
                                <strong class="text-base font-medium">${sat.tleName}</strong>
                            </div>
                             <label class="toggle-switch">
                                <input type="checkbox" class="visibility-toggle" data-id="${id}" ${sat.isVisible ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="mt-1 text-gray-300 leading-tight">
                            <p><strong>NORAD ID:</strong> ${id}</p>
                            <p><strong>Altitude:</strong> <span id="alt-${id}">N/A</span> km</p>
                            <p><strong>Velocity:</strong> <span id="vel-${id}">N/A</span> km/s</p>
                        </div>
                        ${swathControlsHTML}
                    </div>`;
                satelliteListDiv.appendChild(satElement);
                const option = document.createElement('option');
                option.value = id;
                option.textContent = sat.tleName;
                focusSelect.appendChild(option);
            });
            focusSelect.value = focusedSatelliteId || "";
        }

        function updateFocusedSatInfoUI() {
             if (cameraMode === 'satellite' && focusedSatelliteId && trackedSatellites[focusedSatelliteId]) {
                const sat = trackedSatellites[focusedSatelliteId];
                if (focusedSatInfo.dataset.currentSat !== focusedSatelliteId) {
                    focusedSatInfo.dataset.currentSat = focusedSatelliteId;
                    focusedSatInfo.innerHTML = `
                        <div class="flex items-center gap-2">
                            <span class="w-3 h-3 rounded-full" style="background-color: #${sat.color.toString(16).padStart(6, '0')}; border: 1px solid #1a1a1a;"></span>
                            <strong class="text-base font-medium">${sat.tleName}</strong>
                        </div>
                        <div class="mt-1 text-gray-300 leading-tight text-sm">
                            <p><strong>NORAD ID:</strong> <span>${focusedSatelliteId}</span></p>
                            <p><strong>Altitude:</strong> <span id="focused-alt">...</span> km</p>
                            <p><strong>Velocity:</strong> <span id="focused-vel">...</span> km/s</p>
                        </div>
                    `;
                }
                focusedSatInfo.classList.remove('hidden');
            } else {
                focusedSatInfo.classList.add('hidden');
                focusedSatInfo.dataset.currentSat = '';
            }
        }
        
        function setCameraMode(mode) {
            cameraMode = mode;
            if (mode === 'earth') {
                trackEarthBtn.classList.replace('bg-gray-600', 'bg-sky-600');
                trackSatelliteBtn.classList.replace('bg-sky-600', 'bg-gray-600');
                focusControl.classList.add('hidden');
                constellationControl.classList.remove('hidden'); // Show the slider in Earth view
                
                if(focusedSatelliteId) {
                    setFocusedSatellite("");
                }

            } else {
                 trackSatelliteBtn.classList.replace('bg-gray-600', 'bg-sky-600');
                 trackEarthBtn.classList.replace('bg-sky-600', 'bg-gray-600');
                 focusControl.classList.toggle('hidden', Object.keys(trackedSatellites).length === 0);
                 
                 const sat = trackedSatellites[focusedSatelliteId];
                 const isHyperfield = sat && sat.tleName.toUpperCase().includes('HYPERFIELD');
                 constellationControl.classList.toggle('hidden', !isHyperfield);
                 controls.minDistance = 0.1;
            }
            updateFocusedSatInfoUI();
        }
        
        function updateFocusedSatelliteState(noradId) {
            focusedSatelliteId = noradId;
            const sat = trackedSatellites[focusedSatelliteId];
            const isHyperfield = sat && sat.tleName.toUpperCase().includes('HYPERFIELD');
            
            // Only manage the constellation slider visibility when in satellite mode.
            // The 'earth' mode visibility is handled by setCameraMode.
            if (cameraMode === 'satellite') {
                constellationControl.classList.toggle('hidden', !isHyperfield);
            }

            if (focusSelect.value != (noradId || "")) focusSelect.value = noradId || "";
            updateFocusedSatInfoUI();
        }
        
        function setFocusedSatellite(noradId) {
            if (!noradId) {
                if (focusedSatelliteId) { 
                    cameraTransitionState = 'toEarth';
                    cameraTransitionProgress = 0;
                    transitionStartPosition.copy(camera.position);
                    transitionStartTarget.copy(controls.target);
                    transitionEndTarget.set(0, 0, 0);
                    transitionEndPosition.set(0, 15, 30);
                }
                updateFocusedSatelliteState(null);
                return;
            }

            if (noradId === focusedSatelliteId && cameraTransitionState === 'idle') return;
            updateFocusedSatelliteState(noradId);
            
            cameraTransitionState = 'toSat';
            cameraTransitionProgress = 0;
            transitionStartPosition.copy(camera.position);
            transitionStartTarget.copy(controls.target);
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            
            if (isTimeWarping) {
                simulationTime.setMilliseconds(simulationTime.getMilliseconds() + deltaTime * TIME_WARP_FACTOR * 1000);
            } else {
                simulationTime = new Date();
            }
            const now = simulationTime;

            const gmst = satellite.gstime(now);
            
            earth.rotation.y = gmst;
            atmosphere.rotation.y = gmst;
            clouds.rotation.y = gmst * 0.95;
            
            const sunPosition = calculateSunPosition(now);
            directionalLight.position.copy(sunPosition);
            
            for (const id in trackedSatellites) {
                const sat = trackedSatellites[id];
                
                sat.orbit.visible = sat.isVisible;

                const orbitalPeriod = (2 * Math.PI) / sat.satrec.no * 60000;
                const timeOffset = orbitalPeriod / sat.instances.length;
                const epochDate = new Date((sat.satrec.jdsatepoch - 2440587.5) * 86400000);
                const timeSinceEpoch = now.getTime() - epochDate.getTime();

                sat.instances.forEach((instance, index) => {
                    instance.mesh.visible = sat.isVisible;
                    
                    if (!sat.isVisible) {
                        instance.swath.visible = false;
                        instance.beam.visible = false;
                        instance.swathPath.forEach(p => p.visible = false);
                        return;
                    } else {
                         instance.swathPath.forEach(p => p.visible = true);
                    }
                    
                    const instanceTime = new Date(epochDate.getTime() + (timeSinceEpoch + (index * timeOffset)) % orbitalPeriod);
                    
                    const posVel = satellite.propagate(sat.satrec, instanceTime);

                    if (posVel.position && posVel.velocity) {
                        const { position: posEci, velocity: velEci } = posVel;
                        instance.mesh.position.set(posEci.x * SCALING_FACTOR, posEci.z * SCALING_FACTOR, -posEci.y * SCALING_FACTOR);
                        instance.velocity = velEci;
                        
                        const satVelocityVector = new THREE.Vector3(instance.velocity.x, instance.velocity.z, -instance.velocity.y).normalize();
                        instance.mesh.up.copy(satVelocityVector);
                        instance.mesh.lookAt(earth.position);

                        if (index === 0) {
                            const posGd = satellite.eciToGeodetic(posEci, gmst);
                            const altitude = posGd.height;
                            const velocity = Math.sqrt(velEci.x**2 + velEci.y**2 + velEci.z**2);
                            
                            const altEl = document.getElementById(`alt-${id}`);
                            const velEl = document.getElementById(`vel-${id}`);
                            if (altEl) altEl.textContent = altitude.toFixed(2);
                            if (velEl) velEl.textContent = velocity.toFixed(2);

                            if (id === focusedSatelliteId && !focusedSatInfo.classList.contains('hidden')) {
                                const focusedAltEl = document.getElementById('focused-alt');
                                const focusedVelEl = document.getElementById('focused-vel');
                                if(focusedAltEl) focusedAltEl.textContent = altitude.toFixed(2);
                                if(focusedVelEl) focusedVelEl.textContent = velocity.toFixed(2);
                            }
                        }

                        const isHyperfield = sat.tleName.toUpperCase().includes('HYPERFIELD');
                        const isDaySide = instance.mesh.position.clone().normalize().dot(sunPosition.clone().normalize()) > 0.1;
                        
                        const swathShouldBeVisible = (enforceDayNightSwath ? isDaySide : true) && isHyperfield && sat.isSwathVisible;
                        instance.swath.visible = swathShouldBeVisible;
                        instance.beam.visible = swathShouldBeVisible && showBeams;
                        
                        if (swathShouldBeVisible) {
                            const surfacePosition = instance.mesh.position.clone().normalize().multiplyScalar(EARTH_RADIUS_SCALED); // Touches the Earth model
                            instance.swath.position.copy(surfacePosition.clone().normalize().multiplyScalar(EARTH_RADIUS_SCALED * 1.0005)); // Keep swath slightly above to prevent z-fighting
                            
                            const satVelocityVector = new THREE.Vector3(instance.velocity.x, instance.velocity.z, -instance.velocity.y).normalize();
                            instance.swath.up.copy(satVelocityVector);
                            instance.swath.lookAt(earth.position);

                            // Beam logic
                            const satPosition = instance.mesh.position;
                            
                            // Position the beam's base on the surface.
                            instance.beam.position.copy(surfacePosition);
                            // Align the beam's "up" vector (its roll) to match the swath's orientation.
                            instance.beam.up.copy(satVelocityVector);
                            // Point the beam's length (its Z-axis) towards the satellite.
                            instance.beam.lookAt(satPosition);
                            // Scale the beam's length to be exactly the distance from the surface to the satellite.
                            instance.beam.scale.z = surfacePosition.distanceTo(satPosition);


                            if (sat.isSwathRecording) {
                                if (instance.needsSnapshotReset) {
                                    instance.lastSnapshotPosition.copy(instance.mesh.position);
                                    instance.needsSnapshotReset = false;
                                }

                                const snapshotDistance = SWATH_SNAPSHOT_DISTANCE_KM * SCALING_FACTOR;
                                if (instance.mesh.position.distanceTo(instance.lastSnapshotPosition) > 0.0001) {
                                    while (instance.mesh.position.distanceTo(instance.lastSnapshotPosition) > snapshotDistance) {
                                        const direction = instance.mesh.position.clone().sub(instance.lastSnapshotPosition).normalize();
                                        const snapshotPosition3D = instance.lastSnapshotPosition.clone().add(direction.multiplyScalar(snapshotDistance));
                                        
                                        const isSnapshotDaySide = snapshotPosition3D.clone().normalize().dot(sunPosition.clone().normalize()) > 0.1;
                                        if (!enforceDayNightSwath || isSnapshotDaySide) {
                                            const snapshot = createSwath();
                                            snapshot.visible = true;
                                            const surfacePosition = snapshotPosition3D.clone().normalize().multiplyScalar(EARTH_RADIUS_SCALED * 1.0005);
                                            snapshot.position.copy(surfacePosition);
                                            const satVelocityVector = new THREE.Vector3(instance.velocity.x, instance.velocity.z, -instance.velocity.y).normalize();
                                            snapshot.up.copy(satVelocityVector);
                                            snapshot.lookAt(earth.position);
                                            const color = (instance.swathPath.length % 2 === 0) ? 0xffff00 : 0xffa500;
                                            snapshot.material.color.setHex(color);
                                            earth.worldToLocal(snapshot.position);
                                            const earthInverseQuaternion = earth.quaternion.clone().invert();
                                            snapshot.quaternion.premultiply(earthInverseQuaternion);
                                            earth.add(snapshot);
                                            instance.swathPath.push(snapshot);
                                        }
                                        instance.lastSnapshotPosition.copy(snapshotPosition3D);
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            handleCamera(deltaTime);

            controls.update();
            
            if (camera.position.length() < EARTH_RADIUS_SCALED * 1.05) {
                camera.position.setLength(EARTH_RADIUS_SCALED * 1.05);
            }

            renderer.render(scene, camera);
        }

        function easeInOutCubic(x) {
            return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
        }

        function handleCamera(deltaTime) {
            if (cameraTransitionState === 'idle') {
                if (cameraMode === 'satellite' && focusedSatelliteId && trackedSatellites[focusedSatelliteId]) {
                    const sat = trackedSatellites[focusedSatelliteId].instances[0];
                    controls.target.copy(sat.mesh.position);
                }
                return; 
            }

            cameraTransitionProgress += deltaTime;
            let alpha = Math.min(cameraTransitionProgress / transitionDuration, 1.0);
            let easedAlpha = easeInOutCubic(alpha);

            if (cameraTransitionState === 'toSat') {
                if (!focusedSatelliteId || !trackedSatellites[focusedSatelliteId]) {
                    cameraTransitionState = 'idle';
                    return;
                }
                const sat = trackedSatellites[focusedSatelliteId].instances[0];
                transitionEndTarget.copy(sat.mesh.position);
                
                const distance = 15.0; 
                const offset = new THREE.Vector3(sat.velocity.x, sat.velocity.z, -sat.velocity.y)
                    .normalize()
                    .multiplyScalar(-distance);
                transitionEndPosition.copy(sat.mesh.position).add(offset);

                camera.position.copy(transitionStartPosition).lerp(transitionEndPosition, easedAlpha);
                controls.target.copy(transitionStartTarget).lerp(transitionEndTarget, easedAlpha);

            } else if (cameraTransitionState === 'toEarth') {
                camera.position.copy(transitionStartPosition).lerp(transitionEndPosition, easedAlpha);
                controls.target.copy(transitionStartTarget).lerp(transitionEndTarget, easedAlpha);
            }

            if (alpha >= 1.0) {
                if(cameraTransitionState === 'toSat') {
                    const sat = trackedSatellites[focusedSatelliteId].instances[0];
                    controls.target.copy(sat.mesh.position);
                } else if (cameraTransitionState === 'toEarth') {
                    controls.target.set(0,0,0);
                }
                cameraTransitionState = 'idle';
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Update resolution for thick lines
            Object.values(trackedSatellites).forEach(sat => {
                if (sat.orbit && sat.orbit.material.isLineMaterial) {
                    sat.orbit.material.resolution.set(window.innerWidth, window.innerHeight);
                }
            });
        }

        init();
        
    </script>
</body>
</html>

