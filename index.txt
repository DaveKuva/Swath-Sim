<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Chosen Palette: Deep Space -->
    <!-- Application Structure Plan: The application's core is a real-time 3D visualization, which is the most effective way to represent spatial satellite data. The original structure of a main canvas and slide-out control panels is retained for its proven usability. To meet the goal of making data more consumable, I've introduced a third, dedicated 'Analysis' panel. This creates a task-oriented user flow: 1) Observe satellites in the 3D environment. 2) Select a satellite to see its live data. 3) Open the Analysis panel to explore a chart of its altitude over a full orbit. This layered approach allows users to move from general observation to specific, quantitative analysis, translating raw orbital mechanics into an easily digestible chart and fulfilling the core objective of synthesizing complex information. -->
    <!-- Visualization & Content Choices: 
        - Report Info: Real-time satellite position, velocity, orbit path. Goal: Explore spatial relationships. Viz/Presentation: 3D interactive scene. Interaction: Camera pan/zoom/rotate, focus tracking. Justification: Provides intuitive, contextual understanding of satellite orbits in relation to Earth, which is impossible in 2D. Library/Method: Three.js.
        - Report Info: Satellite altitude variation over time. Goal: Analyze change and patterns. Viz/Presentation: 2D Line Chart. Interaction: View chart for any selected satellite. Justification: Converts complex orbital propagation data into a clear, quantitative visual, revealing key characteristics like apogee and perigee at a glance. This makes the data easily consumable as requested. Library/Method: Chart.js/Canvas.
        - Report Info: Application controls (camera, focus, visualization toggles). Goal: User configuration. Viz/Presentation: Interactive UI panels with buttons, sliders, toggles. Interaction: Click/drag controls to modify the 3D scene in real-time. Justification: Groups all user inputs logically, keeping the main visualization uncluttered. Library/Method: HTML/CSS/JS. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kuva Space</title>

    <!-- Web App Manifest & PWA Tags for Borderless Experience -->
    <link rel="manifest" href='data:application/manifest+json;base64,ewogICJuYW1lIjogIkt1dmEgU3BhY2UiLAogICJzaG9ydF9uYW1lIjogIkt1dmEgU3BhY2UiLAogICJzdGFydF91cmwiOiAiLiIsCiAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgImJhY2tncm91bmRfY29sb3IiOiAiIzBBMEEwQSIsCiAgInRoZW1lX2NvbG9yIjogIiMwQTBBMGEiLAogICJkZXNjcmlwdGlvbiI6ICJBbiBpbnRlcmFjdGl2ZSAzRCBzYXRlbGxpdGUgdHJhY2tlciBmcm9tIEt1dmEgU3BhY2UuIiwKICAiaWNvbnMiOiBbCiAgICB7CiAgICAgICJzcmMiOiAiaHR0cHM6Ly9kYXZla3V2YS5naXRodWIuaW8vU3dhdGgtU2ltL2ltYWdlcy9sb2dvLnBuZyIsCiAgICAgICJzaXplcyI6ICIxOTJ4MTkyIiwKICAgICAgInR5cGUiOiAiaW1hZ2UvcG5nIiwKICAgICAgInB1cnBvc2UiOiAiYW55IG1hc2thYmxlIgogICAgfSwKICAgIHsKICAgICAgInNyYyI6ICJodHRwczovL2RhdmVrdXZhLmdpdGh1Yi5pby9Td2F0aC1TaW0vaW1hZ2VzL2xvZ28ucG5nIiwKICAgICAgInNpemVzIjogIjUxMng1MTIiLAogICAgICAidHlwZSI6ICJpbWFnZS9wbmciLAogICAgICAicHVycG9zZSI6ICJhbnkgbWFza2FibGUiCiAgICB9CiAgXQp9'>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Kuva Space">
    <link rel="apple-touch-icon" href="https://davekuva.github.io/Swath-Sim/images/logo.png">
    <meta name="theme-color" content="#0A0A0A">

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @font-face {
            font-family: 'FKGroteskSemiMono';
            /* Use the direct raw.githubusercontent.com links to avoid CORS redirect issues */
            src: url('https://raw.githubusercontent.com/DaveKuva/Swath-Sim/main/Font/FKGroteskSemiMono-Regular.woff2') format('woff2'),
                 url('https://raw.githubusercontent.com/DaveKuva/Swath-Sim/fccf470a3e07c1c9c9d873cb7e996fcac0826947/Font/FKGroteskSemiMono-Regular.woff') format('woff');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'FKGroteskSemiMono', sans-serif;
            background-color: #0A0A0A;
            color: #FDFDFD;
            -webkit-tap-highlight-color: transparent;
        }
        canvas {
            display: block;
        }
        #logo {
            position: absolute;
            top: 1rem;
            left: 1rem;
            width: 75px;
            z-index: 9;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }
        .ui-panel {
            position: absolute;
            z-index: 9;
            padding: 1rem;
            background-color: rgba(10, 10, 10, 0.7);
            border-radius: 0.5rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .slide-panel {
            position: absolute;
            top: 0;
            height: 100vh;
            width: 300px; 
            max-width: 85%;
            background-color: rgba(10, 10, 10, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease-in-out;
            z-index: 10;
            display: flex;
            flex-direction: column;
        }
        #satellitePanel {
            left: 0;
            transform: translateX(-100%);
            border-left: none;
            border-top-right-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }
        #satellitePanel.open {
            transform: translateX(0);
        }
        .panel-toggle {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            background-color: rgba(10, 10, 10, 0.8);
            padding: 1.25rem 0.5rem;
            cursor: pointer;
            font-weight: bold;
            letter-spacing: 2px;
            transition: background-color 0.2s;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-right: none;
            text-transform: capitalize;
        }
        .panel-toggle:hover {
             background-color: rgba(30, 30, 30, 0.9);
        }
        #toggleLeftPanelBtn {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            z-index: 5;
            border-radius: 0 0.5rem 0.5rem 0;
            border-left: none;
        }
        .close-panel-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            font-size: 1.5rem;
            line-height: 1;
            color: #9ca3af;
            cursor: pointer;
            transition: color 0.2s;
            padding: 0.5rem;
            width: 44px;
            height: 44px;
            text-align: center;
        }
        .close-panel-btn:hover {
            color: #FDFDFD;
        }
        #focusedSatInfo {
            max-width: calc(100% - 2rem);
        }
        .sat-item {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 0.75rem;
            margin-bottom: 0.75rem;
        }
        .sat-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .sat-item-clickable:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .custom-select {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FDFDFD%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat; background-position: right .7em top 50%; background-size: .65em auto;
        }
        .toggle-switch { position: relative; display: inline-block; width: 50px; height: 24px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #4a5568; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #A5AEAB; }
        input:checked + .slider:before { transform: translateX(26px); }
        .chevron-icon.rotate-180 { transform: rotate(180deg); }
    </style>
</head>
<body>
    <img id="logo" src="https://davekuva.github.io/Swath-Sim/images/logo.png" alt="Logo">
    <div id="container"></div>

    <div id="toggleLeftPanelBtn" class="panel-toggle">Control panel</div>

    <div id="satellitePanel" class="slide-panel p-0">
        <div class="p-6 pb-4 flex justify-between items-center flex-shrink-0 relative">
            <h2 class="text-xl font-bold">Satellite menu</h2>
            <button id="closeLeftPanelBtn" class="close-panel-btn top-4 right-4 text-2xl">&times;</button>
        </div>

        <div class="overflow-y-auto px-6 pb-6">
            <p class="text-sm text-gray-400 mb-4">Tap a satellite to focus on it. Expand the sections below to access more controls.</p>
            <div id="satelliteList" class="space-y-3 pr-2 border-b border-gray-700 pb-4">
                 <p class="text-gray-400">Loading satellites...</p>
            </div>

            <div id="constellationControl" class="space-y-3 mt-4 pt-4 border-t border-gray-700">
                <label for="constellationSlider" class="font-bold text-sm">Hyperfield constellation size: <span id="constellationCount">2</span></label>
                <input type="range" id="constellationSlider" min="2" max="100" value="2" class="w-full">
                <button id="trackEarthBtn" class="bg-gray-800 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md transition duration-300 w-full border border-gray-600">Global view</button>
                 <div id="focusControl" class="hidden">
                     <label for="focusSelect" class="font-bold text-sm">Focus target</label>
                     <select id="focusSelect" class="custom-select w-full bg-gray-700 text-white rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-gray-500 mt-1"></select>
                </div>
            </div>
            
             <div class="mt-2 pt-2 border-t border-gray-700">
                <button id="toggleAdvancedVisualsBtn" class="w-full text-left font-bold text-md py-2 flex justify-between items-center hover:bg-gray-800 rounded-md px-2">
                    <span>Advanced visuals</span>
                    <svg id="advancedVisualsChevron" class="w-4 h-4 transition-transform duration-300 chevron-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </button>
                <div id="advancedVisualsSection" class="overflow-hidden transition-all duration-300 ease-in-out px-2" style="max-height: 0px;">
                    <div class="py-2">
                        <div class="flex items-center justify-between pt-3"><label for="timeWarpToggle" class="font-bold text-sm text-gray-300">Fast forward (1s=1min)</label><label class="toggle-switch"><input type="checkbox" id="timeWarpToggle"><span class="slider"></span></label></div>
                        <div class="flex items-center justify-between pt-3"><label for="dayNightSwathToggle" class="font-bold text-sm text-gray-300">Day/night swath only</label><label class="toggle-switch"><input type="checkbox" id="dayNightSwathToggle" checked><span class="slider"></span></label></div>
                        <div class="flex items-center justify-between pt-3"><label for="beamsToggle" class="font-bold text-sm text-gray-300">Show satellite beams</label><label class="toggle-switch"><input type="checkbox" id="beamsToggle" checked><span class="slider"></span></label></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="focusedSatInfo" class="ui-panel hidden" style="bottom: 1rem; right: 1rem;"></div>

    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec3 vNormal;
        void main() { vNormal = normalize(normalMatrix * normal); gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
        varying vec3 vNormal;
        void main() { float intensity = pow(0.6 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0); gl_FragColor = vec4(0.3, 0.6, 1.0, 1.0) * intensity; }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/satellite.js/4.1.3/satellite.min.js"></script>
    
    <script>
        // Minimal Service Worker to enable PWA installability
        if ('serviceWorker' in navigator) {
            const sw_string = `
                self.addEventListener('fetch', function(event) {
                    // A very simple service worker that does nothing but exist.
                    // This is enough to trigger the PWA install prompt.
                });
            `;
            const blob = new Blob([sw_string], {type: 'application/javascript'});
            const sw_url = URL.createObjectURL(blob);

            navigator.serviceWorker.register(sw_url)
                .then(function(registration) {
                    console.log('Service Worker registered with scope:', registration.scope);
                })
                .catch(function(error) {
                    console.log('Service Worker registration failed:', error);
                });
        }
    </script>
    
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.128.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';
        import { Line2 } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/lines/Line2.js';
        import { LineMaterial } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/lines/LineMaterial.js';
        import { LineGeometry } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/lines/LineGeometry.js';

        const container = document.getElementById('container');
        const satelliteListDiv = document.getElementById('satelliteList');
        const trackEarthBtn = document.getElementById('trackEarthBtn');
        const focusControl = document.getElementById('focusControl');
        const focusSelect = document.getElementById('focusSelect');
        const satellitePanel = document.getElementById('satellitePanel');
        const toggleLeftPanelBtn = document.getElementById('toggleLeftPanelBtn');
        const closeLeftPanelBtn = document.getElementById('closeLeftPanelBtn');
        const focusedSatInfo = document.getElementById('focusedSatInfo');
        const constellationSlider = document.getElementById('constellationSlider');
        const constellationCount = document.getElementById('constellationCount');
        const timeWarpToggle = document.getElementById('timeWarpToggle');
        const dayNightSwathToggle = document.getElementById('dayNightSwathToggle');
        const beamsToggle = document.getElementById('beamsToggle');
        const toggleAdvancedVisualsBtn = document.getElementById('toggleAdvancedVisualsBtn');
        const advancedVisualsSection = document.getElementById('advancedVisualsSection');
        const advancedVisualsChevron = document.getElementById('advancedVisualsChevron');

        let scene, camera, renderer, controls, directionalLight;
        let earth, clouds, atmosphere;
        const trackedSatellites = {};
        let cameraMode = 'earth';
        let focusedSatelliteId = null;
        let satColorIndex = 0;
        let clock;
        let simulationTime;
        let isTimeWarping = false;
        const TIME_WARP_FACTOR = 60;
        
        let cameraTransitionState = 'idle';
        let cameraTransitionProgress = 0;
        let transitionDuration = 2.5;
        let transitionStartPosition = new THREE.Vector3();
        let transitionStartTarget = new THREE.Vector3();
        let transitionEndPosition = new THREE.Vector3();
        let transitionEndTarget = new THREE.Vector3();

        let enforceDayNightSwath = true;
        let showBeams = true;

        const EARTH_RADIUS_KM = 6371;
        const SCALING_FACTOR = 1 / 1000;
        const EARTH_RADIUS_SCALED = EARTH_RADIUS_KM * SCALING_FACTOR;
        const SAT_COLORS = [0xff6347, 0x9370db, 0x4682b4, 0x32cd32, 0xffd700, 0x00fa9a, 0xff4500, 0x1e90ff];
        const SWATH_SNAPSHOT_DISTANCE_KM = 45; 
        const DEFAULT_TLES = {
            '60562': ['Hyperfield-1A', '1 60562U 24149CY  25273.14645047  .00015321  00000+0  58728-3 0  9993', '2 60562  97.4049 350.0439 0006684 141.6331 218.5385 15.26583021 62307'],
            '64552': ['Hyperfield-1B', '1 64552U 25135AA  25273.18590572  .00010550  00000+0  50593-3 0  9999', '2 64552  97.4478  26.1903 0002229 109.4879 250.6596 15.19077417 15367']
        };

        function init() {
            clock = new THREE.Clock();
            simulationTime = new Date();
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 15, 30);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxDistance = 150;
            
            setCameraMode('earth'); 
            scene.add(new THREE.AmbientLight(0x222222));
            directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            scene.add(directionalLight);

            createSkybox();
            createEarth();
            
            window.addEventListener('resize', onWindowResize, false);
            trackEarthBtn.addEventListener('click', () => setCameraMode('earth'));
            focusSelect.addEventListener('change', (e) => setFocusedSatellite(e.target.value));

            toggleLeftPanelBtn.addEventListener('click', () => satellitePanel.classList.toggle('open'));
            closeLeftPanelBtn.addEventListener('click', () => satellitePanel.classList.remove('open'));

            constellationSlider.addEventListener('input', (e) => {
                const size = parseInt(e.target.value, 10);
                constellationCount.textContent = size;
                updateConstellation(size);
            });
            
            timeWarpToggle.addEventListener('change', (e) => {
                isTimeWarping = e.target.checked;
                if (!isTimeWarping) {
                    for (const id in trackedSatellites) {
                        const sat = trackedSatellites[id];
                        if (sat.isSwathRecording) {
                            clearSwathPath(id);
                            sat.isSwathRecording = false;
                        }
                    }
                    updateSatelliteListUI();
                }
            });

            dayNightSwathToggle.addEventListener('change', (e) => { enforceDayNightSwath = e.target.checked; });
            beamsToggle.addEventListener('change', (e) => { showBeams = e.target.checked; });

            toggleAdvancedVisualsBtn.addEventListener('click', () => {
                const isOpen = advancedVisualsSection.style.maxHeight !== '0px';
                advancedVisualsSection.style.maxHeight = isOpen ? '0px' : advancedVisualsSection.scrollHeight + 'px';
                advancedVisualsChevron.classList.toggle('rotate-180', !isOpen);
            });
           
            satellitePanel.addEventListener('click', (e) => {
                const satItem = e.target.closest('.sat-item-clickable');
                if (satItem && satItem.dataset.id) {
                    const satId = satItem.dataset.id;
                    setCameraMode('satellite');
                    setFocusedSatellite(satId);
                }
            });

            satellitePanel.addEventListener('change', (e) => {
                const satId = e.target.dataset.id;
                if (!satId || !trackedSatellites[satId]) return;
                const sat = trackedSatellites[satId];
                if (e.target.classList.contains('visibility-toggle')) sat.isVisible = e.target.checked;
                else if (e.target.classList.contains('swath-toggle')) sat.isSwathVisible = e.target.checked;
                else if (e.target.classList.contains('record-toggle')) {
                    sat.isSwathRecording = e.target.checked;
                    clearSwathPath(satId);
                }
            });
            
            start();
        }
        
        async function start() {
            setCameraMode('earth');
            await initializeSatellites();
            animate();
        }
        
        function formatSatelliteName(str) {
            if (!str) return '';
            const parts = str.trim().split('-');
            if (parts.length > 1) {
                const baseName = parts[0].charAt(0).toUpperCase() + parts[0].slice(1).toLowerCase();
                const designation = parts.slice(1).join('-').toUpperCase();
                return `${baseName}-${designation}`;
            }
            return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
        }

        async function initializeSatellites() {
            Object.keys(DEFAULT_TLES).forEach(id => addSatellite(id, DEFAULT_TLES[id]));
            focusedSatelliteId = null;
            updateSatelliteListUI();
            await updateAllTLEs();
            setInterval(updateAllTLEs, 3600 * 1000 * 6); // Fetch every 6 hours
        }

        async function updateAllTLEs() {
            console.log("Attempting to update TLEs from CelesTrak...");
            const updateIndicator = document.createElement('p');
            updateIndicator.textContent = 'Updating TLEs...';
            updateIndicator.className = 'text-yellow-400 text-sm p-2 text-center';
            satelliteListDiv.prepend(updateIndicator);

            const tlePromises = Object.keys(trackedSatellites).map(async (noradId) => {
                try {
                    const response = await fetch(`https://celestrak.org/NORAD/elements/gp.php?CATNR=${noradId}&FORMAT=TLE`);
                    if (!response.ok) throw new Error(`HTTP status ${response.status}`);
                    const tleString = await response.text();
                    const tleLines = tleString.trim().split('\r\n');
                    if (tleLines.length < 3) throw new Error('Invalid TLE format received');
                    return { noradId, tleData: [tleLines[0].trim(), tleLines[1].trim(), tleLines[2].trim()], status: 'success' };
                } catch (error) {
                    console.warn(`Failed to fetch TLE for ${noradId}: ${error.message}. Keeping existing data.`);
                    return { noradId, status: 'failed' };
                }
            });

            const results = await Promise.all(tlePromises);
            let needsUiUpdate = false;
            for (const result of results) {
                if (result.status === 'success') {
                    const { noradId, tleData } = result;
                    const sat = trackedSatellites[noradId];
                    const newName = formatSatelliteName(tleData[0]);
                    console.log(`Updating ${noradId} with new TLE for ${newName}`);
                    sat.satrec = satellite.twoline2satrec(tleData[1], tleData[2]);
                    sat.tleName = newName;
                    scene.remove(sat.orbit);
                    sat.orbit = createOrbit(sat.satrec);
                    scene.add(sat.orbit);
                    needsUiUpdate = true;
                }
            }
            if (needsUiUpdate) updateSatelliteListUI();
            updateIndicator.remove();
            return needsUiUpdate;
        }
        
        function createEarth() {
            const textureLoader = new THREE.TextureLoader();
            const earthGeo = new THREE.SphereGeometry(EARTH_RADIUS_SCALED, 32, 32);
            earth = new THREE.Mesh(earthGeo, new THREE.MeshLambertMaterial({ map: textureLoader.load('https://raw.githubusercontent.com/turban/webgl-earth/master/images/2_no_clouds_4k.jpg') }));
            scene.add(earth);
            const cloudGeo = new THREE.SphereGeometry(EARTH_RADIUS_SCALED * 1.005, 32, 32);
            clouds = new THREE.Mesh(cloudGeo, new THREE.MeshPhongMaterial({ map: textureLoader.load('https://raw.githubusercontent.com/turban/webgl-earth/master/images/fair_clouds_4k.png'), transparent: true, opacity: 0.8 }));
            scene.add(clouds);
            const atmoGeo = new THREE.SphereGeometry(EARTH_RADIUS_SCALED * 1.02, 32, 32);
            const atmoMat = new THREE.ShaderMaterial({ vertexShader: document.getElementById('vertexShader').textContent, fragmentShader: document.getElementById('fragmentShader').textContent, blending: THREE.AdditiveBlending, side: THREE.BackSide });
            atmosphere = new THREE.Mesh(atmoGeo, atmoMat);
            scene.add(atmosphere);
        }

        function createSkybox() {
            const texture = new THREE.TextureLoader().load('https://s3-us-west-2.amazonaws.com/s.cdpn.io/141228/starfield.png');
            const skyGeo = new THREE.SphereGeometry(1000, 32, 32);
            const skyMat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide, color: 0x5f5f5f });
            scene.add(new THREE.Mesh(skyGeo, skyMat));
        }
        
        function createSwath() {
            const swathSize = 50 * SCALING_FACTOR;
            const swathGeo = new THREE.PlaneGeometry(swathSize, swathSize);
            const swathMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthTest: false });
            const mesh = new THREE.Mesh(swathGeo, swathMat);
            mesh.renderOrder = 1; 
            mesh.visible = false;
            return mesh;
        }

        function getJulianDate(date) { return (date.getTime() / 86400000) + 2440587.5; }

        function calculateSunPosition(date) {
            const julianDate = getJulianDate(date);
            const d = julianDate - 2451545.0;
            const meanLongitude = (280.460 + 0.9856474 * d) % 360;
            const meanAnomaly = (357.528 + 0.9856003 * d) % 360;
            const eclipticLongitude = meanLongitude + 1.915 * Math.sin(meanAnomaly * Math.PI / 180) + 0.020 * Math.sin(2 * meanAnomaly * Math.PI / 180);
            const obliquity = (23.439 - 0.0000004 * d) * Math.PI / 180;
            const lonRad = eclipticLongitude * Math.PI / 180;
            const sunX = Math.cos(lonRad), sunY = Math.sin(lonRad) * Math.cos(obliquity), sunZ = Math.sin(lonRad) * Math.sin(obliquity);
            return new THREE.Vector3(sunX * 100, sunY * 100, sunZ * 100);
        }

        function addSatellite(noradId, tleData) {
            if (!tleData) return;
            const tleName = tleData[0];
            const satrec = satellite.twoline2satrec(tleData[1], tleData[2]);
            const mainSat = createSatelliteInstance(true);
            trackedSatellites[noradId] = { satrec, tleName, color: mainSat.mesh.material.color.getHex(), orbit: createOrbit(satrec), instances: [mainSat], isVisible: true, isSwathVisible: false, isSwathRecording: false };
            scene.add(trackedSatellites[noradId].orbit);
        }

        function createSatelliteInstance(isMain = false) {
             const newColor = isMain ? SAT_COLORS[satColorIndex++ % SAT_COLORS.length] : 0xaaaaaa;
             const baseSize = 0.08, scaleFactor = baseSize / 366; 
             const mainSatSize = { x: 226 * scaleFactor, y: 100 * scaleFactor, z: 366 * scaleFactor };
             const instanceSatSize = { x: mainSatSize.x / 2, y: mainSatSize.y / 2, z: mainSatSize.z / 2 };
             const size = isMain ? mainSatSize : instanceSatSize;
    
             const satGeo = new THREE.BoxGeometry(size.x, size.y, size.z);
             const satMat = new THREE.MeshBasicMaterial({ color: newColor });
             const satMesh = new THREE.Mesh(satGeo, satMat);
             scene.add(satMesh);
             
             const swath = createSwath();
             scene.add(swath);
             
             const swathSize = 50 * SCALING_FACTOR;
             const radiusBottom = swathSize / Math.sqrt(2);
             const beamGeo = new THREE.CylinderGeometry(0.001, radiusBottom, 1, 4, 1);
             beamGeo.rotateY(Math.PI / 4); beamGeo.rotateX(Math.PI / 2); beamGeo.translate(0, 0, 0.5); 
             const beamMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.25, side: THREE.DoubleSide, depthWrite: false, depthTest: false });
             const beam = new THREE.Mesh(beamGeo, beamMat);
             scene.add(beam);
             
             return { mesh: satMesh, swath, beam, swathPath: [], lastSnapshotPosition: new THREE.Vector3(), needsSnapshotReset: true, velocity: { x: 0, y: 0, z: 0 } };
        }

        function updateConstellation(size) {
            ['60562', '64552'].forEach(id => {
                if (trackedSatellites[id]) {
                    for(let i = 1; i < trackedSatellites[id].instances.length; i++) {
                        const instance = trackedSatellites[id].instances[i];
                        scene.remove(instance.mesh); scene.remove(instance.swath); scene.remove(instance.beam);
                        instance.swathPath.forEach(p => earth.remove(p));
                    }
                    trackedSatellites[id].instances.splice(1);
                }
            });
            
            const countA = Math.ceil(size / 2), countB = Math.floor(size / 2);
            for(let i = 1; i < countA; i++) if (trackedSatellites['60562']) trackedSatellites['60562'].instances.push(createSatelliteInstance());
            for(let i = 1; i < countB; i++) if (trackedSatellites['64552']) trackedSatellites['64552'].instances.push(createSatelliteInstance());
        }
        
        function clearSwathPath(noradId) {
            const sat = trackedSatellites[noradId];
            if (sat) sat.instances.forEach(inst => {
                inst.swathPath.forEach(swath => earth.remove(swath));
                inst.swathPath = [];
                inst.needsSnapshotReset = true;
            });
        }

        function createOrbit(satrec) {
            const points = [];
            const orbitalPeriod = (2 * Math.PI) / satrec.no;
            const segments = 1024;
            const epochDate = new Date((satrec.jdsatepoch - 2440587.5) * 86400000);
            for (let i = 0; i <= segments; i++) {
                const time = new Date(epochDate.getTime() + (i / segments) * orbitalPeriod * 60000);
                const positionEci = satellite.propagate(satrec, time).position;
                if (positionEci) points.push(positionEci.x * SCALING_FACTOR, positionEci.z * SCALING_FACTOR, -positionEci.y * SCALING_FACTOR);
            }
            
            const lineGeo = new LineGeometry();
            lineGeo.setPositions(points);
            const lineMat = new LineMaterial({ color: 0xffffff, linewidth: 2, transparent: true, opacity: 0.5, resolution: new THREE.Vector2(window.innerWidth, window.innerHeight) });
            const orbitLine = new Line2(lineGeo, lineMat);
            orbitLine.computeLineDistances();
            return orbitLine;
        }

        function updateSatelliteListUI() {
            satelliteListDiv.innerHTML = '';
            focusSelect.innerHTML = '';
            const placeholder = document.createElement('option');
            placeholder.value = ""; placeholder.textContent = "Select a satellite..."; placeholder.disabled = true;
            focusSelect.appendChild(placeholder);
            const satelliteIds = Object.keys(trackedSatellites);
            if (satelliteIds.length === 0) {
                satelliteListDiv.innerHTML = '<p class="text-gray-400">No satellites tracked.</p>';
                return;
            }
            satelliteIds.forEach(id => {
                const sat = trackedSatellites[id];
                const satElement = document.createElement('div');
                satElement.className = 'sat-item text-sm';
                
                const isHyperfield = sat.tleName.toLowerCase().includes('hyperfield');
                const swathControlsHTML = isHyperfield ? `
                    <div class="mt-2 pt-2 space-y-2">
                        <div class="flex items-center justify-between"><label class="text-sm text-gray-400">Show live swath</label><label class="toggle-switch"><input type="checkbox" class="swath-toggle" data-id="${id}" ${sat.isSwathVisible ? 'checked' : ''}><span class="slider"></span></label></div>
                        <div class="flex items-center justify-between"><label class="text-sm text-gray-400">Record swath path</label><label class="toggle-switch"><input type="checkbox" class="record-toggle" data-id="${id}" ${sat.isSwathRecording ? 'checked' : ''}><span class="slider"></span></label></div>
                    </div>` : '';

                satElement.innerHTML = `<div class="sat-item-clickable p-2 rounded-md transition-colors duration-200 cursor-pointer" data-id="${id}">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-2 pointer-events-none">
                            <span class="w-3 h-3 rounded-full" style="background-color: #${sat.color.toString(16).padStart(6, '0')}; border: 1px solid #1a1a1a;"></span>
                            <strong class="text-base font-medium">${sat.tleName}</strong>
                        </div>
                        <label class="toggle-switch"><input type="checkbox" class="visibility-toggle" data-id="${id}" ${sat.isVisible ? 'checked' : ''}><span class="slider"></span></label>
                    </div>
                    <div class="mt-1 text-gray-300 leading-tight pointer-events-none">
                        <p><strong>NORAD ID:</strong> ${id}</p>
                        <p><strong>Altitude:</strong> <span id="alt-${id}">N/A</span> km</p>
                        <p><strong>Velocity:</strong> <span id="vel-${id}">N/A</span> km/s</p>
                    </div>
                    </div>
                    ${swathControlsHTML}
                `;
                satelliteListDiv.appendChild(satElement);
                const option = document.createElement('option');
                option.value = id; option.textContent = sat.tleName;
                focusSelect.appendChild(option);
            });
            focusSelect.value = focusedSatelliteId || "";
        }

        function updateFocusedSatInfoUI() {
             if (cameraMode === 'satellite' && focusedSatelliteId && trackedSatellites[focusedSatelliteId]) {
                const sat = trackedSatellites[focusedSatelliteId];
                if (focusedSatInfo.dataset.currentSat !== focusedSatelliteId) {
                    focusedSatInfo.dataset.currentSat = focusedSatelliteId;
                    focusedSatInfo.innerHTML = `
                        <div class="flex items-center gap-2">
                            <span class="w-3 h-3 rounded-full" style="background-color: #${sat.color.toString(16).padStart(6, '0')}; border: 1px solid #1a1a1a;"></span>
                            <strong class="text-base font-medium">${sat.tleName}</strong>
                        </div>
                        <div class="mt-1 text-gray-300 leading-tight text-sm">
                            <p><strong>NORAD ID:</strong> <span>${focusedSatelliteId}</span></p>
                            <p><strong>Altitude:</strong> <span id="focused-alt">...</span> km</p>
                            <p><strong>Velocity:</strong> <span id="focused-vel">...</span> km/s</p>
                        </div>`;
                }
                focusedSatInfo.classList.remove('hidden');
            } else {
                focusedSatInfo.classList.add('hidden');
                focusedSatInfo.dataset.currentSat = '';
            }
        }
        
        function setCameraMode(mode) {
            cameraMode = mode;
            if (mode === 'earth') {
                trackEarthBtn.classList.replace('bg-gray-800', 'bg-gray-600');
                focusControl.classList.add('hidden');
                constellationControl.classList.remove('hidden');
                if(focusedSatelliteId) setFocusedSatellite("");
            } else {
                 trackEarthBtn.classList.replace('bg-gray-600', 'bg-gray-800');
                 focusControl.classList.remove('hidden');
                 const sat = trackedSatellites[focusedSatelliteId];
                 const isHyperfield = sat && sat.tleName.toLowerCase().includes('hyperfield');
                 constellationControl.classList.toggle('hidden', !isHyperfield);
                 controls.minDistance = 0.1;
            }
            updateFocusedSatInfoUI();
        }
        
        function updateFocusedSatelliteState(noradId) {
            focusedSatelliteId = noradId;
            const sat = trackedSatellites[focusedSatelliteId];
            const isHyperfield = sat && sat.tleName.toLowerCase().includes('hyperfield');
            
            if (cameraMode === 'satellite') constellationControl.classList.toggle('hidden', !isHyperfield);
            if (focusSelect.value != (noradId || "")) focusSelect.value = noradId || "";
            updateFocusedSatInfoUI();
        }
        
        function setFocusedSatellite(noradId) {
            if (!noradId) {
                if (focusedSatelliteId) { 
                    cameraTransitionState = 'toEarth';
                    cameraTransitionProgress = 0;
                    transitionStartPosition.copy(camera.position);
                    transitionStartTarget.copy(controls.target);
                    transitionEndTarget.set(0, 0, 0);
                    transitionEndPosition.set(0, 15, 30);
                }
                updateFocusedSatelliteState(null);
                return;
            }
            if (noradId === focusedSatelliteId && cameraTransitionState === 'idle') return;
            updateFocusedSatelliteState(noradId);
            cameraTransitionState = 'toSat';
            cameraTransitionProgress = 0;
            transitionStartPosition.copy(camera.position);
            transitionStartTarget.copy(controls.target);
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            
            if (isTimeWarping) simulationTime.setMilliseconds(simulationTime.getMilliseconds() + deltaTime * TIME_WARP_FACTOR * 1000);
            else simulationTime = new Date();
            
            const now = simulationTime;
            const gmst = satellite.gstime(now);
            
            if(earth) earth.rotation.y = gmst; 
            if(atmosphere) atmosphere.rotation.y = gmst; 
            if(clouds) clouds.rotation.y = gmst * 0.95;
            
            const sunPosition = calculateSunPosition(now);
            directionalLight.position.copy(sunPosition);
            
            for (const id in trackedSatellites) {
                const sat = trackedSatellites[id];
                sat.orbit.visible = sat.isVisible;
                const orbitalPeriod = (2 * Math.PI) / sat.satrec.no * 60000;
                const timeOffset = orbitalPeriod / sat.instances.length;
                const epochDate = new Date((sat.satrec.jdsatepoch - 2440587.5) * 86400000);
                const timeSinceEpoch = now.getTime() - epochDate.getTime();

                sat.instances.forEach((instance, index) => {
                    instance.mesh.visible = sat.isVisible;
                    if (!sat.isVisible) {
                        instance.swath.visible = false; instance.beam.visible = false; instance.swathPath.forEach(p => p.visible = false);
                        return;
                    } else {
                         instance.swathPath.forEach(p => p.visible = true);
                    }
                    
                    const instanceTime = new Date(epochDate.getTime() + (timeSinceEpoch + (index * timeOffset)) % orbitalPeriod);
                    const posVel = satellite.propagate(sat.satrec, instanceTime);

                    if (posVel.position && posVel.velocity) {
                        const { position: posEci, velocity: velEci } = posVel;
                        instance.mesh.position.set(posEci.x * SCALING_FACTOR, posEci.z * SCALING_FACTOR, -posEci.y * SCALING_FACTOR);
                        instance.velocity = velEci;
                        
                        const satVelocityVector = new THREE.Vector3(instance.velocity.x, instance.velocity.z, -instance.velocity.y).normalize();
                        instance.mesh.up.copy(satVelocityVector);
                        instance.mesh.lookAt(earth.position);

                        if (index === 0) {
                            const posGd = satellite.eciToGeodetic(posEci, gmst);
                            const altitude = posGd.height;
                            const velocity = Math.sqrt(velEci.x**2 + velEci.y**2 + velEci.z**2);
                            const altEl = document.getElementById(`alt-${id}`), velEl = document.getElementById(`vel-${id}`);
                            if (altEl) altEl.textContent = altitude.toFixed(2);
                            if (velEl) velEl.textContent = velocity.toFixed(2);
                            if (id === focusedSatelliteId && !focusedSatInfo.classList.contains('hidden')) {
                                const focusedAltEl = document.getElementById('focused-alt'), focusedVelEl = document.getElementById('focused-vel');
                                if(focusedAltEl) focusedAltEl.textContent = altitude.toFixed(2);
                                if(focusedVelEl) focusedVelEl.textContent = velocity.toFixed(2);
                            }
                        }

                        const isHyperfield = sat.tleName.toLowerCase().includes('hyperfield');
                        const isDaySide = instance.mesh.position.clone().normalize().dot(sunPosition.clone().normalize()) > 0.1;
                        const swathShouldBeVisible = (enforceDayNightSwath ? isDaySide : true) && isHyperfield && sat.isSwathVisible;
                        instance.swath.visible = swathShouldBeVisible;
                        instance.beam.visible = swathShouldBeVisible && showBeams;
                        
                        if (swathShouldBeVisible) {
                            const surfacePosition = instance.mesh.position.clone().normalize().multiplyScalar(EARTH_RADIUS_SCALED * 1.0005);
                            instance.swath.position.copy(surfacePosition);
                            const satVelVec = new THREE.Vector3(instance.velocity.x, instance.velocity.z, -instance.velocity.y).normalize();
                            instance.swath.up.copy(satVelVec);
                            instance.swath.lookAt(earth.position);
                            instance.beam.position.copy(surfacePosition);
                            instance.beam.up.copy(satVelVec);
                            instance.beam.lookAt(instance.mesh.position);
                            instance.beam.scale.z = surfacePosition.distanceTo(instance.mesh.position);

                            if (sat.isSwathRecording) {
                                const createAndPlaceSnapshot = (position3D) => {
                                    const isSnapshotDaySide = position3D.clone().normalize().dot(sunPosition.clone().normalize()) > 0.1;
                                    if (!enforceDayNightSwath || isSnapshotDaySide) {
                                        const snapshot = createSwath();
                                        snapshot.visible = true;
                                        snapshot.position.copy(position3D.clone().normalize().multiplyScalar(EARTH_RADIUS_SCALED * 1.0005));
                                        const satVelocityVector = new THREE.Vector3(instance.velocity.x, instance.velocity.z, -instance.velocity.y).normalize();
                                        snapshot.up.copy(satVelocityVector);
                                        snapshot.lookAt(earth.position);
                                        snapshot.material.color.setHex((instance.swathPath.length % 2 === 0) ? 0xffff00 : 0xffa500);
                                        earth.worldToLocal(snapshot.position);
                                        snapshot.quaternion.premultiply(earth.quaternion.clone().invert());
                                        earth.add(snapshot);
                                        instance.swathPath.push(snapshot);
                                    }
                                };
                                
                                if (instance.needsSnapshotReset) {
                                    createAndPlaceSnapshot(instance.mesh.position);
                                    instance.lastSnapshotPosition.copy(instance.mesh.position);
                                    instance.needsSnapshotReset = false;
                                }
                                const snapshotDistance = SWATH_SNAPSHOT_DISTANCE_KM * SCALING_FACTOR;
                                while (instance.mesh.position.distanceTo(instance.lastSnapshotPosition) > snapshotDistance) {
                                    const direction = instance.mesh.position.clone().sub(instance.lastSnapshotPosition).normalize();
                                    const nextSnapshotPosition = instance.lastSnapshotPosition.clone().add(direction.multiplyScalar(snapshotDistance));
                                    createAndPlaceSnapshot(nextSnapshotPosition);
                                    instance.lastSnapshotPosition.copy(nextSnapshotPosition);
                                }
                            }
                        }
                    }
                });
            }
            handleCamera(deltaTime);
            controls.update();
            if (camera.position.length() < EARTH_RADIUS_SCALED * 1.05) camera.position.setLength(EARTH_RADIUS_SCALED * 1.05);
            renderer.render(scene, camera);
        }

        function easeInOutCubic(x) { return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2; }

        function handleCamera(deltaTime) {
            if (cameraTransitionState === 'idle') {
                if (cameraMode === 'satellite' && focusedSatelliteId && trackedSatellites[focusedSatelliteId]) {
                    controls.target.copy(trackedSatellites[focusedSatelliteId].instances[0].mesh.position);
                }
                return; 
            }
            cameraTransitionProgress += deltaTime;
            let alpha = easeInOutCubic(Math.min(cameraTransitionProgress / transitionDuration, 1.0));
            if (cameraTransitionState === 'toSat') {
                if (!focusedSatelliteId || !trackedSatellites[focusedSatelliteId]) { cameraTransitionState = 'idle'; return; }
                const sat = trackedSatellites[focusedSatelliteId].instances[0];
                transitionEndTarget.copy(sat.mesh.position);
                const offset = new THREE.Vector3(sat.velocity.x, sat.velocity.z, -sat.velocity.y).normalize().multiplyScalar(-15.0);
                transitionEndPosition.copy(sat.mesh.position).add(offset);
                camera.position.copy(transitionStartPosition).lerp(transitionEndPosition, alpha);
                controls.target.copy(transitionStartTarget).lerp(transitionEndTarget, alpha);
            } else if (cameraTransitionState === 'toEarth') {
                camera.position.copy(transitionStartPosition).lerp(transitionEndPosition, alpha);
                controls.target.copy(transitionStartTarget).lerp(transitionEndTarget, alpha);
            }
            if (alpha >= 1.0) {
                if(cameraTransitionState === 'toSat') controls.target.copy(trackedSatellites[focusedSatelliteId].instances[0].mesh.position);
                else if (cameraTransitionState === 'toEarth') controls.target.set(0,0,0);
                cameraTransitionState = 'idle';
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            Object.values(trackedSatellites).forEach(sat => {
                if (sat.orbit && sat.orbit.material.isLineMaterial) {
                    sat.orbit.material.resolution.set(window.innerWidth, window.innerHeight);
                }
            });
        }
        init();
    </script>
</body>
</html>

