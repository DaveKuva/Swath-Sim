<!DOCTYPE html>

<html lang="en">

<head>

    <!-- Chosen Palette: Deep Space -->

    <!-- Application Structure Plan: The application's core is a real-time 3D visualization, which is the most effective way to represent spatial satellite data. The original structure of a main canvas and slide-out control panels is retained for its proven usability. To meet the goal of making data more consumable, I've introduced a third, dedicated 'Analysis' panel. This creates a task-oriented user flow: 1) Observe satellites in the 3D environment. 2) Select a satellite to see its live data. 3) Open the Analysis panel to explore a chart of its altitude over a full orbit. This layered approach allows users to move from general observation to specific, quantitative analysis, translating raw orbital mechanics into an easily digestible chart and fulfilling the core objective of synthesizing complex information. -->

    <!-- Visualization & Content Choices: 

        - Report Info: Real-time satellite position, velocity, orbit path. Goal: Explore spatial relationships. Viz/Presentation: 3D interactive scene. Interaction: Camera pan/zoom/rotate, focus tracking. Justification: Provides intuitive, contextual understanding of satellite orbits in relation to Earth, which is impossible in 2D. Library/Method: Three.js.

        - Report Info: Satellite altitude variation over time. Goal: Analyze change and patterns. Viz/Presentation: 2D Line Chart. Interaction: View chart for any selected satellite. Justification: Converts complex orbital propagation data into a clear, quantitative visual, revealing key characteristics like apogee and perigee at a glance. This makes the data easily consumable as requested. Library/Method: Chart.js/Canvas.

        - Report Info: Application controls (camera, focus, visualization toggles). Goal: User configuration. Viz/Presentation: Interactive UI panels with buttons, sliders, toggles. Interaction: Click/drag controls to modify the 3D scene in real-time. Justification: Groups all user inputs logically, keeping the main visualization uncluttered. Library/Method: HTML/CSS/JS. -->

    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kuva Space</title>
    <!-- Web App Manifest & PWA Tags for Borderless Experience -->
    <link rel="manifest" href='data:application/manifest+json;base64,eyJuYW1lIjoiS3V2YSBTcGFjZSIsInNob3J0X25hbWUiOiJLdXZhIFNwYWNlIiwic3RhcnRfdXJsIjoiLiIsInNjb3BlIjoiLyIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwiZGlzcGxheV9vdmVycmlkZSI6WyJzdGFuZGFsb25lIiwibWluaW1hbC11aSJdLCJiYWNrZ3JvdW5kX2NvbG9yIjoiIzAwMDAwMCIsInRoZW1lX2NvbG9yIjoiIzAwMDAwMCIsImRlc2NyaXB0aW9uIjoiQW4gaW50ZXJhY3RpdmUgM0Qgc2F0ZWxsaXRlIHRyYWNrZXIgZnJvbSBLdXZhIFNwYWNlLiIsImljb25zIjpbeyJzcmMiOiJodHRwczovL2dpdGh1Yi5jb20vRGF2ZUt1dmEva3V2YS1zaW0vYmxvYi9tYWluL2ltYWdlcy9rcy1hcHAtaWNvbi5wbmc/cmF3PXRydWUiLCJzaXplcyI6IjE5MngxOTIiLCJ0eXBlIjoiaW1hZ2UvcG5nIiwicHVycG9zZSI6ImFueSBtYXNrYWJsZSJ9LHsic3JjIjoiaHR0cHM6Ly9naXRodWIuY29tL0RhdmVLdXZhL2t1dmEtc2ltL2Jsb2IvbWFpbi9pbWFnZXMva3MtYXBwLWljb24ucG5nP3Jhdz10cnVlIiwic2l6ZXMiOiI1MTJ4NTEyIiwidHlwZSI6ImltYWdlL3BuZyIsInB1cnBvc2UiOiJhbnkgbWFza2FibGUifV19'>
    <link rel="icon" type="image/png" href="https://github.com/DaveKuva/kuva-sim/blob/main/images/ks-app-icon.png?raw=true">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Kuva Space">

    <link rel="apple-touch-icon" href="https://github.com/DaveKuva/kuva-sim/blob/main/images/ks-app-icon.png?raw=true">

    <meta name="theme-color" content="#000000">

    <script src="https://cdn.tailwindcss.com"></script>

    <style>

        @font-face {

            font-family: 'FKGroteskSemiMono';

            /* Use the direct raw.githubusercontent.com links to avoid CORS redirect issues */

            src: url('https://raw.githubusercontent.com/DaveKuva/kuva-sim/main/Font/FKGroteskSemiMono-Regular.woff2') format('woff2'),

                 url('https://raw.githubusercontent.com/DaveKuva/kuva-sim/fccf470a3e07c1c9c9d873cb7e996fcac0826947/Font/FKGroteskSemiMono-Regular.woff') format('woff');

            font-weight: normal;

            font-style: normal;

            font-display: swap;

        }

        body {

            margin: 0;

            overflow: hidden;

            font-family: 'FKGroteskSemiMono', sans-serif;

            background-color: #0A0A0A;

            color: #FDFDFD;

            -webkit-tap-highlight-color: transparent;

        }

        canvas {

            display: block;

        }

        #logo {

            position: absolute;

            top: 1rem;

            left: 1rem;

            width: 75px;

            z-index: 9;

            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));

        }

        .ui-panel {

            position: absolute;

            z-index: 9;

            padding: 1rem;

            background-color: rgba(10, 10, 10, 0.7);

            border-radius: 0.5rem;

            backdrop-filter: blur(10px);

            border: 1px solid rgba(255, 255, 255, 0.1);

            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);

        }

        .slide-panel {

            position: absolute;

            top: 0;

            height: 100vh;

            width: 300px; 

            max-width: 85%;

            background-color: rgba(10, 10, 10, 0.8);

            backdrop-filter: blur(10px);

            border: 1px solid rgba(255, 255, 255, 0.1);

            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);

            transition: transform 0.3s ease-in-out;

            z-index: 10;

            display: flex;

            flex-direction: column;

        }

        #satellitePanel {

            left: 0;

            transform: translateX(-100%);

            border-left: none;

            border-top-right-radius: 0.5rem;

            border-bottom-right-radius: 0.5rem;

        }

        #satellitePanel.open {

            transform: translateX(0);

        }

        .panel-toggle {

            writing-mode: vertical-rl;

            text-orientation: mixed;

            background-color: rgba(10, 10, 10, 0.8);

            padding: 1.25rem 0.5rem;

            cursor: pointer;

            font-weight: bold;

            letter-spacing: 2px;

            transition: background-color 0.2s;

            border: 1px solid rgba(255, 255, 255, 0.1);

            border-right: none;

            text-transform: capitalize;

        }

        .panel-toggle:hover {

             background-color: rgba(30, 30, 30, 0.9);

        }

        #toggleLeftPanelBtn {

            position: absolute;

            left: 0;

            top: 50%;

            transform: translateY(-50%);

            z-index: 5;

            border-radius: 0 0.5rem 0.5rem 0;

            border-left: none;

        }

        .close-panel-btn {

            position: absolute;

            top: 0.5rem;

            right: 0.5rem;

            font-size: 1.5rem;

            line-height: 1;

            color: #9ca3af;

            cursor: pointer;

            transition: color 0.2s;

            padding: 0.5rem;

            width: 44px;

            height: 44px;

            text-align: center;

        }

        .close-panel-btn:hover {

            color: #FDFDFD;

        }

        #focusedSatInfo {

            max-width: calc(100% - 2rem);

        }

        .sat-item {

            border-bottom: 1px solid rgba(255, 255, 255, 0.1);

            padding-bottom: 0.75rem;

            margin-bottom: 0.75rem;

        }

        .sat-item:last-child {

            border-bottom: none;

            margin-bottom: 0;

            padding-bottom: 0;

        }

        .sat-item-clickable:hover {

            background-color: rgba(255, 255, 255, 0.1);

        }

        .custom-select {

            -webkit-appearance: none; -moz-appearance: none; appearance: none;

            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FDFDFD%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');

            background-repeat: no-repeat; background-position: right .7em top 50%; background-size: .65em auto;

        }

        .toggle-switch { position: relative; display: inline-block; width: 50px; height: 24px; }

        .toggle-switch input { opacity: 0; width: 0; height: 0; }

        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #4a5568; transition: .4s; border-radius: 24px; }

        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }

        input:checked + .slider { background-color: #A5AEAB; }

        input:checked + .slider:before { transform: translateX(26px); }

        .chevron-icon.rotate-180 { transform: rotate(180deg); }

    </style>

</head>

<body>

    <img id="logo" src="https://davekuva.github.io/kuva-sim/images/logo.png" alt="Logo">

    <div id="container"></div>

    <div id="toggleLeftPanelBtn" class="panel-toggle">Control panel</div>

    <div id="satellitePanel" class="slide-panel p-0">

        <div class="p-6 pb-4 flex justify-between items-center flex-shrink-0 relative">

            <h2 class="text-xl font-bold">Control panel</h2>

            <button id="closeLeftPanelBtn" class="close-panel-btn top-4 right-4 text-2xl">&times;</button>

        </div>

        <div class="overflow-y-auto px-6 pb-6">

            <p class="text-sm text-gray-400 mb-4">Tap a satellite to focus on it. Expand the sections below to access more controls.</p>

            <div>

                <button id="toggleSatelliteListBtn" class="w-full text-left font-bold text-md py-2 flex justify-between items-center hover:bg-gray-800 rounded-md px-2">

                    <span>Satellites</span>

                    <svg id="satelliteListChevron" class="w-4 h-4 transition-transform duration-300 chevron-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>

                </button>

                <div id="satelliteListContainer" class="overflow-hidden transition-all duration-300 ease-in-out px-2">

                    <div id="satelliteList" class="space-y-3 pt-2">

                         <p class="text-gray-400">Loading satellites...</p>

                    </div>

                </div>

            </div>

            <div id="constellationControl" class="space-y-3 mt-4 pt-4 border-t border-gray-700">

                <label for="constellationSlider" class="font-bold text-sm">Hyperfield constellation size: <span id="constellationCount">2</span></label>

                <input type="range" id="constellationSlider" min="2" max="100" value="2" class="w-full">

                <button id="trackEarthBtn" class="bg-gray-800 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md transition duration-300 w-full border border-gray-600">Global view</button>

                 <div id="focusControl" class="hidden">

                     <label for="focusSelect" class="font-bold text-sm">Focus target</label>

                     <select id="focusSelect" class="custom-select w-full bg-gray-700 text-white rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-gray-500 mt-1"></select>

                </div>

            </div>

            

             <div class="mt-2 pt-2 border-t border-gray-700">

                <button id="toggleAdvancedVisualsBtn" class="w-full text-left font-bold text-md py-2 flex justify-between items-center hover:bg-gray-800 rounded-md px-2">

                    <span>Advanced settings</span>

                    <svg id="advancedVisualsChevron" class="w-4 h-4 transition-transform duration-300 chevron-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>

                </button>

                <div id="advancedVisualsSection" class="overflow-hidden transition-all duration-300 ease-in-out px-2" style="max-height: 0px;">

                    <div class="py-2">

                        <div class="flex items-center justify-between pt-3"><label for="timeWarpToggle" class="font-bold text-sm text-gray-300">Fast forward (1s=1min)</label><label class="toggle-switch"><input type="checkbox" id="timeWarpToggle"><span class="slider"></span></label></div>

                        <div class="flex items-center justify-between pt-3"><label for="dayNightSwathToggle" class="font-bold text-sm text-gray-300">Day/night swath only</label><label class="toggle-switch"><input type="checkbox" id="dayNightSwathToggle" checked><span class="slider"></span></label></div>

                        <div class="flex items-center justify-between pt-3"><label for="beamsToggle" class="font-bold text-sm text-gray-300">Show satellite beams</label><label class="toggle-switch"><input type="checkbox" id="beamsToggle" checked><span class="slider"></span></label></div>

                        <div class="flex items-center justify-between pt-3"><label for="demoModeToggle" class="font-bold text-sm text-gray-300">Demo Sunlit Pass</label><label class="toggle-switch"><input type="checkbox" id="demoModeToggle"><span class="slider"></span></label></div>

                    </div>

                </div>

            </div>

        </div>

    </div>

    

    <div id="focusedSatInfo" class="ui-panel hidden" style="bottom: 1rem; right: 1rem;"></div>

    <script id="vertexShader" type="x-shader/x-vertex">

        varying vec3 vNormal;

        void main() { 

            vNormal = normalize(normalMatrix * normal); 

            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); 

        }

    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">

        uniform float uOpacity;

        varying vec3 vNormal;

        void main() { 

            float intensity = pow(0.5 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 1.5); 

            vec4 color = vec4(0.3, 0.6, 1.0, 1.0) * intensity * 1.5;

            gl_FragColor = vec4(color.rgb, color.a * uOpacity);

        }

    </script>

     <script id="cityLightsVertexShader" type="x-shader/x-vertex">

        varying vec2 vUv;

        varying vec3 vWorldNormal;

        void main() {

            vUv = uv;

            vWorldNormal = normalize(mat3(modelMatrix) * normal);

            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

        }

    </script>

    <script id="cityLightsFragmentShader" type="x-shader/x-fragment">

        uniform sampler2D cityTexture;

        uniform vec3 sunDirection;

        varying vec2 vUv;

        varying vec3 vWorldNormal;

        void main() {

            float intensity = dot(vWorldNormal, normalize(sunDirection));

            float night = smoothstep(0.25, -0.25, intensity);

            vec4 texColor = texture2D(cityTexture, vUv);

            gl_FragColor = vec4(texColor.rgb * 1.5, texColor.a * night);

        }

    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/satellite.js/4.1.3/satellite.min.js"></script>

    

    <script>

        // Minimal Service Worker to enable PWA installability

        if ('serviceWorker' in navigator) {

            const sw_string = `

                self.addEventListener('fetch', function(event) {

                    // This is enough to trigger the PWA install prompt.

                });

            `;

            const blob = new Blob([sw_string], {type: 'application/javascript'});

            const sw_url = URL.createObjectURL(blob);

            navigator.serviceWorker.register(sw_url)

                .then(function(registration) {

                    console.log('Service Worker registered with scope:', registration.scope);

                })

                .catch(function(error) {

                    console.log('Service Worker registration failed:', error);

                });

        }

    </script>

    

    <script type="module">

        import * as THREE from 'https://cdn.skypack.dev/three@0.128.0';

        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';

        import { Line2 } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/lines/Line2.js';

        import { LineMaterial } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/lines/LineMaterial.js';

        import { LineGeometry } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/lines/LineGeometry.js';

        const container = document.getElementById('container');

        const satelliteListDiv = document.getElementById('satelliteList');

        const trackEarthBtn = document.getElementById('trackEarthBtn');

        const focusControl = document.getElementById('focusControl');

        const focusSelect = document.getElementById('focusSelect');

        const satellitePanel = document.getElementById('satellitePanel');

        const toggleLeftPanelBtn = document.getElementById('toggleLeftPanelBtn');

        const closeLeftPanelBtn = document.getElementById('closeLeftPanelBtn');

        const focusedSatInfo = document.getElementById('focusedSatInfo');

        const constellationSlider = document.getElementById('constellationSlider');

        const constellationCount = document.getElementById('constellationCount');

        const timeWarpToggle = document.getElementById('timeWarpToggle');

        const dayNightSwathToggle = document.getElementById('dayNightSwathToggle');

        const beamsToggle = document.getElementById('beamsToggle');

        const toggleAdvancedVisualsBtn = document.getElementById('toggleAdvancedVisualsBtn');

        const advancedVisualsSection = document.getElementById('advancedVisualsSection');

        const advancedVisualsChevron = document.getElementById('advancedVisualsChevron');

        const toggleSatelliteListBtn = document.getElementById('toggleSatelliteListBtn');

        const satelliteListContainer = document.getElementById('satelliteListContainer');

        const satelliteListChevron = document.getElementById('satelliteListChevron');

        const demoModeToggle = document.getElementById('demoModeToggle');
        const constellationControl = document.getElementById('constellationControl');

        

        let pressStartTime = 0;

        let startX = 0;

        let startY = 0;

        const MAX_PRESS_DURATION = 200; // ms

        const MAX_MOVE_DISTANCE = 10; // pixels

        let scene, camera, renderer, controls, directionalLight;

        let earth, clouds, atmosphere, cityLights;

        const trackedSatellites = {};

        let cameraMode = 'earth';

        let focusedSatelliteId = null;

        let satColorIndex = 0;

        let clock;

        let simulationTime;

        let isTimeWarping = false;

        let isDemoMode = false;

        

        let cameraTransitionState = 'idle';

        let cameraTransitionProgress = 0;

        let transitionDuration = 2.5;

        let transitionStartPosition = new THREE.Vector3();

        let transitionStartTarget = new THREE.Vector3();

        let transitionEndPosition = new THREE.Vector3();

        let transitionEndTarget = new THREE.Vector3();

        let enforceDayNightSwath = true;

        let showBeams = true;
        const EARTH_RADIUS_KM = 6371;
        const SCALING_FACTOR = 1 / 1000;
        const EARTH_RADIUS_SCALED = EARTH_RADIUS_KM * SCALING_FACTOR;
        const TIME_WARP_FACTOR = 60; // 1 second in real-time = 1 minute in simulation
        const SAT_COLORS = [0xff6347, 0x9370db, 0x4682b4, 0x32cd32, 0xffd700, 0x00fa9a, 0xff4500, 0x1e90ff];
        const SWATH_SNAPSHOT_DISTANCE_KM = 45; 
        const MAX_SWATH_SNAPSHOTS = 20000; // Maximum number of path segments per satellite instance
        
        // A reusable dummy object for efficient matrix calculations to avoid creating new objects in the render loop.
        const dummyMatrixObject = new THREE.Object3D();
        const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0); // For clearing instanced meshes
        

        const DEFAULT_TLES = {
            '60562': ['HYPERFIELD-1A', '1 60562U 24149CY  25280.68391397  .00009245  00000+0  35371-3 0  9993', '2 60562  97.4052 357.5179 0007005 119.8281 240.3655 15.26773275 63455'],
            '64552': ['HYPERFIELD-1B', '1 64552U 25135AA  25280.95826816  .00007948  00000+0  38032-3 0  9996', '2 64552  97.4498  33.8537 0002276  97.1876 262.9617 15.19235477 16542']

        };

        function init() {

            clock = new THREE.Clock();

            simulationTime = new Date();

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);

            camera.position.set(0, 15, 30);

            

            renderer = new THREE.WebGLRenderer({ antialias: true });

            renderer.setSize(window.innerWidth, window.innerHeight);

            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));

            renderer.outputColorSpace = THREE.SRGBColorSpace;

            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);

            controls.enableDamping = true;

            controls.maxDistance = 150;

            

            setCameraMode('earth'); 

            scene.add(new THREE.AmbientLight(0x111111));

            directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);

            scene.add(directionalLight);

            createSkybox();

            createEarth();

            

            window.addEventListener('resize', onWindowResize, false);

            trackEarthBtn.addEventListener('click', () => setCameraMode('earth'));

            focusSelect.addEventListener('change', (e) => setFocusedSatellite(e.target.value));

            demoModeToggle.addEventListener('change', (e) => {

                isDemoMode = e.target.checked;

                if (isDemoMode) {

                    const demoSatId = '64552'; // Use Hyperfield-1B for positioning

                    if (trackedSatellites[demoSatId]) {

                         simulationTime = findNextFinlandPass(trackedSatellites[demoSatId].satrec);

                    }

                } else {

                    simulationTime = new Date();

                    // When turning off demo mode, also turn off swath recording for all satellites.

                    for (const id in trackedSatellites) {

                        const sat = trackedSatellites[id];

                        if (sat.isSwathRecording) {

                            sat.isSwathRecording = false;

                            clearSwathPath(id);

                        }

                    }

                    updateSatelliteListUI(); // Update UI to reflect the change in toggles

                }

            });

            toggleLeftPanelBtn.addEventListener('click', () => satellitePanel.classList.toggle('open'));

            closeLeftPanelBtn.addEventListener('click', () => satellitePanel.classList.remove('open'));

            container.addEventListener('pointerdown', (e) => {

                pressStartTime = Date.now();

                startX = e.clientX;

                startY = e.clientY;

            });

            container.addEventListener('pointerup', (e) => {

                const pressDuration = Date.now() - pressStartTime;

                const distanceX = Math.abs(e.clientX - startX);

                const distanceY = Math.abs(e.clientY - startY);

                

                if (pressDuration < MAX_PRESS_DURATION && distanceX < MAX_MOVE_DISTANCE && distanceY < MAX_MOVE_DISTANCE) {

                    if (satellitePanel.classList.contains('open')) {

                        satellitePanel.classList.remove('open');

                    }

                }

            });

            constellationSlider.addEventListener('input', (e) => {

                const size = parseInt(e.target.value, 10);

                constellationCount.textContent = size;

                updateConstellation(size);

            });

            

            timeWarpToggle.addEventListener('change', (e) => {

                isTimeWarping = e.target.checked;

                if (!isTimeWarping && !isDemoMode) { // Only reset time if not in demo mode

                    simulationTime = new Date();

                }

                if (!isTimeWarping) {

                    // When time warp is turned off, also turn off swath recording for all satellites.

                    for (const id in trackedSatellites) {

                        const sat = trackedSatellites[id];

                        if (sat.isSwathRecording) {

                            sat.isSwathRecording = false;

                            clearSwathPath(id);

                        }

                    }

                    updateSatelliteListUI(); // Update UI to reflect the change in toggles

                }

            });

            dayNightSwathToggle.addEventListener('change', (e) => { enforceDayNightSwath = e.target.checked; });

            beamsToggle.addEventListener('change', (e) => { showBeams = e.target.checked; });

            toggleAdvancedVisualsBtn.addEventListener('click', () => {

                const isOpen = advancedVisualsSection.style.maxHeight !== '0px';

                advancedVisualsSection.style.maxHeight = isOpen ? '0px' : advancedVisualsSection.scrollHeight + 'px';

                advancedVisualsChevron.classList.toggle('rotate-180', !isOpen);

            });

           

            toggleSatelliteListBtn.addEventListener('click', () => {

                const isOpen = satelliteListContainer.style.maxHeight !== '0px' && satelliteListContainer.style.maxHeight;

                satelliteListContainer.style.maxHeight = isOpen ? '0px' : satelliteListContainer.scrollHeight + 'px';

                satelliteListChevron.classList.toggle('rotate-180');

            });

            satellitePanel.addEventListener('click', (e) => {
                const satItem = e.target.closest('.sat-item-clickable');
                if (satItem && satItem.dataset.id) {
                    const satId = satItem.dataset.id;
                    setFocusedSatellite(satId); // Set the active satellite first
                    setCameraMode('satellite'); // Then update the UI based on that satellite
                }
            });

            satellitePanel.addEventListener('change', (e) => {

                const satId = e.target.dataset.id;

                if (!satId || !trackedSatellites[satId]) return;

                const sat = trackedSatellites[satId];

                if (e.target.classList.contains('visibility-toggle')) sat.isVisible = e.target.checked;

                else if (e.target.classList.contains('swath-toggle')) sat.isSwathVisible = e.target.checked;

                else if (e.target.classList.contains('record-toggle')) {

                    sat.isSwathRecording = e.target.checked;

                    clearSwathPath(satId);

                }

            });

            

            start();

        }

        

        async function start() {
            setCameraMode('earth');
            await initializeSatellites();
            animate();
            // Set satellite list to be open by default - logic moved to updateSatelliteListUI
        }
        
        function formatSatelliteName(str) {
            if (!str) return '';

            const parts = str.trim().split('-');

            if (parts.length > 1) {

                const baseName = parts[0].charAt(0).toUpperCase() + parts[0].slice(1).toLowerCase();

                const designation = parts.slice(1).join('-').toUpperCase();

                return `${baseName}-${designation}`;

            }

            return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
        }
        async function initializeSatellites() {
            Object.keys(DEFAULT_TLES).forEach(id => addSatellite(id, DEFAULT_TLES[id]));
            focusedSatelliteId = null;
            updateSatelliteListUI(true);
            // await updateAllTLEs(); // Disabled automatic TLE fetch on load to prevent rate-limiting.
            setInterval(updateAllTLEs, 3600 * 1000 * 6); // Fetch every 6 hours
        }
        async function updateAllTLEs() {
            console.log("Attempting to update TLEs from CelesTrak...");

            const updateIndicator = document.createElement('p');

            updateIndicator.textContent = 'Updating TLEs...';

            updateIndicator.className = 'text-yellow-400 text-sm p-2 text-center';

            satelliteListDiv.prepend(updateIndicator);

            const tlePromises = Object.keys(trackedSatellites).map(async (noradId) => {

                try {

                    const response = await fetch(`https://celestrak.org/NORAD/elements/gp.php?CATNR=${noradId}&FORMAT=TLE`);

                    if (!response.ok) throw new Error(`HTTP status ${response.status}`);

                    const tleString = await response.text();

                    const tleLines = tleString.trim().split('\\r\\n');

                    if (tleLines.length < 3) throw new Error('Invalid TLE format received');

                    return { noradId, tleData: [tleLines[0].trim(), tleLines[1].trim(), tleLines[2].trim()], status: 'success' };

                } catch (error) {

                    console.warn(`Failed to fetch TLE for ${noradId}: ${error.message}. Keeping existing data.`);

                    return { noradId, status: 'failed' };

                }

            });

            const results = await Promise.all(tlePromises);

            let needsUiUpdate = false;

            for (const result of results) {

                if (result.status === 'success') {

                    const { noradId, tleData } = result;

                    const sat = trackedSatellites[noradId];

                    const newName = formatSatelliteName(tleData[0]);

                    console.log(`Updating ${noradId} with new TLE for ${newName}`);

                    sat.satrec = satellite.twoline2satrec(tleData[1], tleData[2]);

                    sat.tleName = newName;

                    scene.remove(sat.orbit);

                    sat.orbit = createOrbit(sat.satrec);

                    scene.add(sat.orbit);

                    needsUiUpdate = true;

                }

            }

            if (needsUiUpdate) updateSatelliteListUI();

            updateIndicator.remove();

        }

        

        function createEarth() {

            const textureLoader = new THREE.TextureLoader();

            const earthGeo = new THREE.SphereGeometry(EARTH_RADIUS_SCALED, 32, 32);

            earth = new THREE.Mesh(earthGeo, new THREE.MeshLambertMaterial({ map: textureLoader.load('https://raw.githubusercontent.com/DaveKuva/kuva-sim/main/images/2_no_clouds_4k.jpg') }));

            scene.add(earth);

            const lightsGeo = new THREE.SphereGeometry(EARTH_RADIUS_SCALED * 1.002, 32, 32);

            const lightsMat = new THREE.ShaderMaterial({

                uniforms: {

                    cityTexture: { value: textureLoader.load('https://raw.githubusercontent.com/DaveKuva/kuva-sim/main/images/land_lights_16384.png') },

                    sunDirection: { value: new THREE.Vector3() }

                },

                vertexShader: document.getElementById('cityLightsVertexShader').textContent,

                fragmentShader: document.getElementById('cityLightsFragmentShader').textContent,

                blending: THREE.AdditiveBlending,

                transparent: true,

                depthTest: false

            });

            cityLights = new THREE.Mesh(lightsGeo, lightsMat);

            scene.add(cityLights);

            const cloudGeo = new THREE.SphereGeometry(EARTH_RADIUS_SCALED * 1.005, 32, 32);

            clouds = new THREE.Mesh(cloudGeo, new THREE.MeshPhongMaterial({ map: textureLoader.load('https://raw.githubusercontent.com/DaveKuva/kuva-sim/main/images/fair_clouds_4k.png'), transparent: true, opacity: 0.8 }));

            scene.add(clouds);

            const atmoGeo = new THREE.SphereGeometry(EARTH_RADIUS_SCALED * 1.05, 32, 32);

            const atmoMat = new THREE.ShaderMaterial({ 

                uniforms: {

                    uOpacity: { value: 1.0 }

                },

                vertexShader: document.getElementById('vertexShader').textContent, 

                fragmentShader: document.getElementById('fragmentShader').textContent, 

                blending: THREE.AdditiveBlending, 

                side: THREE.BackSide,

                transparent: true,

                depthWrite: false

            });

            atmosphere = new THREE.Mesh(atmoGeo, atmoMat);

            scene.add(atmosphere);

        }

        function createSkybox() {

            const texture = new THREE.TextureLoader().load('https://s3-us-west-2.amazonaws.com/s.cdpn.io/141228/starfield.png');

            const skyGeo = new THREE.SphereGeometry(1000, 32, 32);

            const skyMat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide, color: 0xcccccc });

            scene.add(new THREE.Mesh(skyGeo, skyMat));

        }

        

        function createSwath() {

            const swathSize = 50 * SCALING_FACTOR;

            const swathGeo = new THREE.PlaneGeometry(swathSize, swathSize);

            const swathMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthTest: false });

            const mesh = new THREE.Mesh(swathGeo, swathMat);

            mesh.renderOrder = 1; 

            mesh.visible = false;

            return mesh;

        }

        function getJulianDate(date) { return (date.getTime() / 86400000) + 2440587.5; }

        function calculateAccurateSunPosition(date) {

            const toRad = Math.PI / 180;

            const julianDate = getJulianDate(date);

            const T = (julianDate - 2451545.0) / 36525;

            let L0 = 280.46646 + T * (36000.76983 + T * 0.0003032);

            L0 = L0 % 360;

            let M = 357.52911 + T * (35999.05029 - T * 0.0001537);

            M = M % 360;

            const Mrad = M * toRad;

            const C = (1.914602 - T * (0.004817 + 0.000014 * T)) * Math.sin(Mrad) + (0.019993 - T * 0.000101) * Math.sin(2 * Mrad) + 0.000289 * Math.sin(3 * Mrad);

            const sunTrueLongitude = L0 + C;

            const sunTrueLongitudeRad = sunTrueLongitude * toRad;

            let epsilon = 23 + (26 / 60) + (21.448 / 3600) - T * ((46.8150 / 3600) + T * ((0.00059 / 3600) - T * (0.001813 / 3600)));

            const epsilonRad = epsilon * toRad;

            const sunX = Math.cos(sunTrueLongitudeRad);

            const sunY = Math.sin(sunTrueLongitudeRad) * Math.cos(epsilonRad);

            const sunZ = Math.sin(sunTrueLongitudeRad) * Math.sin(epsilonRad);

            const distanceScale = 100;

            return new THREE.Vector3(sunX * distanceScale, sunZ * distanceScale, -sunY * distanceScale);

        }

        function addSatellite(noradId, tleData) {

            if (!tleData) return;

            const tleName = tleData[0];

            const satrec = satellite.twoline2satrec(tleData[1].trim(), tleData[2].trim());

            const mainSat = createSatelliteInstance(true);

            trackedSatellites[noradId] = { satrec, tleName, color: mainSat.mesh.material.color.getHex(), orbit: createOrbit(satrec), instances: [mainSat], isVisible: true, isSwathVisible: true, isSwathRecording: false };

            scene.add(trackedSatellites[noradId].orbit);

        }

        function createSatelliteInstance(isMain = false) {

             const newColor = isMain ? SAT_COLORS[satColorIndex++ % SAT_COLORS.length] : 0xaaaaaa;

             const baseSize = 0.08, scaleFactor = baseSize / 366; 

             const mainSatSize = { x: 226 * scaleFactor, y: 100 * scaleFactor, z: 366 * scaleFactor };

             const instanceSatSize = { x: mainSatSize.x / 2, y: mainSatSize.y / 2, z: mainSatSize.z / 2 };

             const size = isMain ? mainSatSize : instanceSatSize;

    

             const satGeo = new THREE.BoxGeometry(size.x, size.y, size.z);

             const satMat = new THREE.MeshBasicMaterial({ color: newColor });

             const satMesh = new THREE.Mesh(satGeo, satMat);

             scene.add(satMesh);

             

             const swath = createSwath();

             scene.add(swath);

             

             const swathSize = 50 * SCALING_FACTOR;

             const radiusBottom = swathSize / Math.sqrt(2);

             const beamGeo = new THREE.CylinderGeometry(0.001, radiusBottom, 1, 4, 1);

             beamGeo.rotateY(Math.PI / 4); beamGeo.rotateX(Math.PI / 2); beamGeo.translate(0, 0, 0.5); 

             const beamMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.25, side: THREE.DoubleSide, depthWrite: false, depthTest: false });
             const beam = new THREE.Mesh(beamGeo, beamMat);
             scene.add(beam);
             
             // --- Performance Optimization: Use InstancedMesh for swath paths ---
             const swathPathGeo = new THREE.PlaneGeometry(swathSize, swathSize);
             const yellowMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthTest: false });
             const orangeMat = new THREE.MeshBasicMaterial({ color: 0xffa500, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthTest: false });

             const instancedSwathYellow = new THREE.InstancedMesh(swathPathGeo, yellowMat, MAX_SWATH_SNAPSHOTS);
             const instancedSwathOrange = new THREE.InstancedMesh(swathPathGeo, orangeMat, MAX_SWATH_SNAPSHOTS);

             instancedSwathYellow.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
             instancedSwathOrange.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
             
             instancedSwathYellow.renderOrder = 0; // Render paths before live elements
             instancedSwathOrange.renderOrder = 0;

             earth.add(instancedSwathYellow, instancedSwathOrange);

             return { mesh: satMesh, swath, beam, lastSnapshotPosition: new THREE.Vector3(), needsSnapshotReset: true, velocity: { x: 0, y: 0, z: 0 }, instancedSwathYellow, instancedSwathOrange, swathCount: 0 };
        }

        function updateConstellation(size) {
            ['60562', '64552'].forEach(id => {
                if (trackedSatellites[id]) {
                    for(let i = 1; i < trackedSatellites[id].instances.length; i++) {
                        const instance = trackedSatellites[id].instances[i];
                        scene.remove(instance.mesh); scene.remove(instance.swath); scene.remove(instance.beam);
                        // Clean up instanced meshes
                        earth.remove(instance.instancedSwathYellow);
                        earth.remove(instance.instancedSwathOrange);
                        instance.instancedSwathYellow.dispose();
                        instance.instancedSwathOrange.dispose();
                    }
                    trackedSatellites[id].instances.splice(1);
                }
            });
            
            const countA = Math.ceil(size / 2), countB = Math.floor(size / 2);
            for(let i = 1; i < countA; i++) if (trackedSatellites['60562']) trackedSatellites['60562'].instances.push(createSatelliteInstance());
            for(let i = 1; i < countB; i++) if (trackedSatellites['64552']) trackedSatellites['64552'].instances.push(createSatelliteInstance());
        }
        

        function clearSwathPath(noradId) {
            const sat = trackedSatellites[noradId];
            if (sat) sat.instances.forEach(inst => {
                // Explicitly clear matrices for the currently rendered instances by scaling them to zero.
                // This prevents "ghost" segments from previous recordings from appearing on the GPU.
                for (let i = 0; i < inst.instancedSwathYellow.count; i++) {
                    inst.instancedSwathYellow.setMatrixAt(i, zeroMatrix);
                }
                for (let i = 0; i < inst.instancedSwathOrange.count; i++) {
                    inst.instancedSwathOrange.setMatrixAt(i, zeroMatrix);
                }
                
                // After clearing, reset the render count to zero.
                inst.instancedSwathYellow.count = 0;
                inst.instancedSwathOrange.count = 0;
                
                // Flag the instance matrix as needing an update on the GPU.
                inst.instancedSwathYellow.instanceMatrix.needsUpdate = true;
                inst.instancedSwathOrange.instanceMatrix.needsUpdate = true;
                
                // Reset our internal counters.
                inst.swathCount = 0; 
                inst.needsSnapshotReset = true;
            });
        }

        function createOrbit(satrec) {
            const points = [];

            const orbitalPeriod = (2 * Math.PI) / satrec.no;

            const segments = 1024;

            const epochDate = new Date((satrec.jdsatepoch - 2440587.5) * 86400000);

            for (let i = 0; i <= segments; i++) {

                const time = new Date(epochDate.getTime() + (i / segments) * orbitalPeriod * 60000);

                const positionEci = satellite.propagate(satrec, time).position;

                if (positionEci) points.push(positionEci.x * SCALING_FACTOR, positionEci.z * SCALING_FACTOR, -positionEci.y * SCALING_FACTOR);

            }

            

            const lineGeo = new LineGeometry();

            lineGeo.setPositions(points);

            const lineMat = new LineMaterial({ color: 0xffffff, linewidth: 2, transparent: true, opacity: 0.5, resolution: new THREE.Vector2(window.innerWidth, window.innerHeight) });
            const orbitLine = new Line2(lineGeo, lineMat);
            orbitLine.computeLineDistances();
            return orbitLine;
        }
        function updateSatelliteListUI(isInitialLoad = false) {
            satelliteListDiv.innerHTML = '';
            focusSelect.innerHTML = '';
            const placeholder = document.createElement('option');

            placeholder.value = ""; placeholder.textContent = "Select a satellite..."; placeholder.disabled = true;

            focusSelect.appendChild(placeholder);

            const satelliteIds = Object.keys(trackedSatellites);

            if (satelliteIds.length === 0) {

                satelliteListDiv.innerHTML = '<p class="text-gray-400">No satellites tracked.</p>';

                return;

            }

            satelliteIds.forEach(id => {

                const sat = trackedSatellites[id];

                const satElement = document.createElement('div');

                satElement.className = 'sat-item text-sm';

                

                const isHyperfield = sat.tleName.toLowerCase().includes('hyperfield');

                const swathControlsHTML = isHyperfield ? `

                    <div class="mt-2 pt-2 space-y-2">

                        <div class="flex items-center justify-between"><label class="text-sm text-gray-400">Show live swath</label><label class="toggle-switch"><input type="checkbox" class="swath-toggle" data-id="${id}" ${sat.isSwathVisible ? 'checked' : ''}><span class="slider"></span></label></div>

                        <div class="flex items-center justify-between"><label class="text-sm text-gray-400">Record swath path</label><label class="toggle-switch"><input type="checkbox" class="record-toggle" data-id="${id}" ${sat.isSwathRecording ? 'checked' : ''}><span class="slider"></span></label></div>

                    </div>` : '';

                satElement.innerHTML = `<div class="sat-item-clickable p-2 rounded-md transition-colors duration-200 cursor-pointer" data-id="${id}">

                    <div class="flex items-center justify-between">

                        <div class="flex items-center gap-2 pointer-events-none">

                            <span class="w-3 h-3 rounded-full" style="background-color: #${sat.color.toString(16).padStart(6, '0')}; border: 1px solid #1a1a1a;"></span>

                            <strong class="text-base font-medium">${sat.tleName}</strong>

                        </div>

                        <label class="toggle-switch"><input type="checkbox" class="visibility-toggle" data-id="${id}" ${sat.isVisible ? 'checked' : ''}><span class="slider"></span></label>

                    </div>

                    <div class="mt-1 text-gray-300 leading-tight pointer-events-none">

                        <p><strong>NORAD ID:</strong> ${id}</p>

                        <p><strong>Altitude:</strong> <span id="alt-${id}">N/A</span> km</p>

                        <p><strong>Velocity:</strong> <span id="vel-${id}">N/A</span> km/s</p>

                    </div>

                    </div>

                    ${swathControlsHTML}

                `;

                satelliteListDiv.appendChild(satElement);

                const option = document.createElement('option');

                option.value = id; option.textContent = sat.tleName;

                focusSelect.appendChild(option);

            });

            focusSelect.value = focusedSatelliteId || "";

            

            // After populating, if the panel is open, resize it to fit new content.
            const isOpen = satelliteListContainer.style.maxHeight !== '0px' && satelliteListContainer.style.maxHeight;
            if (isOpen) {
                satelliteListContainer.style.maxHeight = satelliteListContainer.scrollHeight + 'px';
            }

            if (isInitialLoad) {
                // Use a timeout to ensure the browser has calculated the scrollHeight of the new content
                setTimeout(() => {
                    satelliteListContainer.style.maxHeight = satelliteListContainer.scrollHeight + 'px';
                    satelliteListChevron.classList.add('rotate-180');
                }, 100);
            }
        }
        function updateFocusedSatInfoUI() {
             if (cameraMode === 'satellite' && focusedSatelliteId && trackedSatellites[focusedSatelliteId]) {
                const sat = trackedSatellites[focusedSatelliteId];

                if (focusedSatInfo.dataset.currentSat !== focusedSatelliteId) {

                    focusedSatInfo.dataset.currentSat = focusedSatelliteId;

                    focusedSatInfo.innerHTML = `

                        <div class="flex items-center gap-2">

                            <span class="w-3 h-3 rounded-full" style="background-color: #${sat.color.toString(16).padStart(6, '0')}; border: 1px solid #1a1a1a;"></span>

                            <strong class="text-base font-medium">${sat.tleName}</strong>

                        </div>

                        <div class="mt-1 text-gray-300 leading-tight text-sm">

                            <p><strong>NORAD ID:</strong> <span>${focusedSatelliteId}</span></p>

                            <p><strong>Altitude:</strong> <span id="focused-alt">...</span> km</p>

                            <p><strong>Velocity:</strong> <span id="focused-vel">...</span> km/s</p>

                        </div>`;

                }

                focusedSatInfo.classList.remove('hidden');

            } else {

                focusedSatInfo.classList.add('hidden');

                focusedSatInfo.dataset.currentSat = '';

            }

        }

        

        function setCameraMode(mode) {

            cameraMode = mode;

            if (mode === 'earth') {

                trackEarthBtn.classList.replace('bg-gray-800', 'bg-gray-600');

                focusControl.classList.add('hidden');

                constellationControl.classList.remove('hidden');

                if(focusedSatelliteId) setFocusedSatellite("");

            } else {

                 trackEarthBtn.classList.replace('bg-gray-600', 'bg-gray-800');

                 focusControl.classList.remove('hidden');

                 const sat = trackedSatellites[focusedSatelliteId];

                 const isHyperfield = sat && sat.tleName.toLowerCase().includes('hyperfield');

                 constellationControl.classList.toggle('hidden', !isHyperfield);

                 controls.minDistance = 0.1;

            }

            updateFocusedSatInfoUI();

        }

        
        function setFocusedSatellite(noradId) {
            if (!noradId) {
                if (focusedSatelliteId) { // If we were focused on something
                    cameraTransitionState = 'toEarth';
                    cameraTransitionProgress = 0;
                    transitionStartPosition.copy(camera.position);
                    transitionStartTarget.copy(controls.target);
                    transitionEndPosition.set(0, 15, 30); // Sensible default Earth view
                    transitionEndTarget.set(0, 0, 0);
                }
                focusedSatelliteId = null;
                if (focusSelect) focusSelect.value = "";
            } else {
                focusedSatelliteId = noradId;
                if (focusSelect) focusSelect.value = noradId;
                cameraTransitionState = 'toSat';
                cameraTransitionProgress = 0;
                transitionStartPosition.copy(camera.position);
                transitionStartTarget.copy(controls.target);
                // The end position and target will be calculated in the handleCamera function
            }
            updateFocusedSatInfoUI();
        }
        function findNextFinlandPass(satrec) {
            // This function now sets a specific, fixed date and time for the demo
            // to ensure the satellites are in the "perfect spot" as requested by the user.
            // Time is based on the provided context: Wed, Oct 8, 2025 10:26 AM EEST (UTC+3)
            console.log("Setting simulation to a fixed demo time based on user-identified 'perfect spot'.");
            return new Date('2025-10-08T07:26:00.000Z');
        }
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            if (isTimeWarping) {
                simulationTime.setMilliseconds(simulationTime.getMilliseconds() + deltaTime * TIME_WARP_FACTOR * 1000);
            } else if (!isDemoMode) {
                simulationTime = new Date(); // In normal mode, always sync to real time
            } else {
                // In demo mode, but not time warping, time progresses normally from its set point
                simulationTime.setMilliseconds(simulationTime.getMilliseconds() + deltaTime * 1000);
            }

            const now = simulationTime;

            // Calculate GMST for physics and data, which must always align with the satellite's time.
            const gmstForData = satellite.gstime(now);

            // In demo mode, calculate a separate GMST for the Earth's visual rotation.
            // This allows us to shift the Earth's view without altering the satellite's physical position.
            let gmstForVisuals;
            if (isDemoMode) {
                // Offset time by +5 hours for the Earth's rotation in demo mode.
                const earthTime = new Date(now.getTime() + (5 * 60 * 60 * 1000));
                gmstForVisuals = satellite.gstime(earthTime);
            } else {
                gmstForVisuals = gmstForData;
            }

            if(earth) earth.rotation.y = gmstForVisuals; 
            if(atmosphere) atmosphere.rotation.y = gmstForVisuals; 
            if(clouds) clouds.rotation.y = gmstForVisuals * 0.95;
            if(cityLights) cityLights.rotation.y = gmstForVisuals;

            const sunPosition = calculateAccurateSunPosition(now);
            directionalLight.position.copy(sunPosition);
            if (cityLights) {
                 cityLights.material.uniforms.sunDirection.value.copy(sunPosition);
            }
            
            for (const id in trackedSatellites) {
                const sat = trackedSatellites[id];
                sat.orbit.visible = sat.isVisible;
                const orbitalPeriod = (2 * Math.PI) / sat.satrec.no * 60000;
                const timeOffset = orbitalPeriod / sat.instances.length;
                const epochDate = new Date((sat.satrec.jdsatepoch - 2440587.5) * 86400000);
                const timeSinceEpoch = now.getTime() - epochDate.getTime();
                sat.instances.forEach((instance, index) => {
                    instance.mesh.visible = sat.isVisible;
                    // Also toggle visibility of the entire recorded path.
                    instance.instancedSwathYellow.visible = sat.isVisible;
                    instance.instancedSwathOrange.visible = sat.isVisible;

                    if (!sat.isVisible) {
                        instance.swath.visible = false; instance.beam.visible = false;
                        return;
                    }
                    
                    const instanceTime = new Date(epochDate.getTime() + (timeSinceEpoch + (index * timeOffset)) % orbitalPeriod);
                    const posVel = satellite.propagate(sat.satrec, instanceTime);
                    if (posVel.position && posVel.velocity) {
                        const { position: posEci, velocity: velEci } = posVel;
                        instance.mesh.position.set(posEci.x * SCALING_FACTOR, posEci.z * SCALING_FACTOR, -posEci.y * SCALING_FACTOR);
                        instance.velocity = velEci;
                        
                        const satVelocityVector = new THREE.Vector3(instance.velocity.x, instance.velocity.z, -instance.velocity.y).normalize();
                        instance.mesh.up.copy(satVelocityVector);
                        instance.mesh.lookAt(earth.position);
                        if (index === 0) {
                            const posGd = satellite.eciToGeodetic(posEci, gmstForData);
                            const altitude = posGd.height;
                            const velocity = Math.sqrt(velEci.x**2 + velEci.y**2 + velEci.z**2);
                            const altEl = document.getElementById(`alt-${id}`), velEl = document.getElementById(`vel-${id}`);
                            if (altEl) altEl.textContent = altitude.toFixed(2);
                            if (velEl) velEl.textContent = velocity.toFixed(2);
                            if (id === focusedSatelliteId && !focusedSatInfo.classList.contains('hidden')) {
                                const focusedAltEl = document.getElementById('focused-alt'), focusedVelEl = document.getElementById('focused-vel');
                                if(focusedAltEl) focusedAltEl.textContent = altitude.toFixed(2);
                                if(focusedVelEl) focusedVelEl.textContent = velocity.toFixed(2);
                            }
                        }
                        
                        // --- LOGIC RESTRUCTURED TO FIX SWATH RECORDING FOR ALL INSTANCES ---
                        const isHyperfield = sat.tleName.toLowerCase().includes('hyperfield');
                        if (!isHyperfield) {
                            // Ensure non-hyperfield sats never show a swath or beam
                            instance.swath.visible = false;
                            instance.beam.visible = false;
                        } else {
                             const isDaySide = instance.mesh.position.clone().normalize().dot(sunPosition.clone().normalize()) > 0.1;
                             // Visibility for the LIVE swath and beam still depends on the day/night toggle.
                             const liveSwathShouldBeVisible = sat.isSwathVisible && (!enforceDayNightSwath || isDaySide);
                             
                             instance.swath.visible = liveSwathShouldBeVisible;
                             instance.beam.visible = liveSwathShouldBeVisible && showBeams;
                             
                             if (liveSwathShouldBeVisible) {
                                const surfacePosition = instance.mesh.position.clone().normalize().multiplyScalar(EARTH_RADIUS_SCALED * 1.0005);
                                instance.swath.position.copy(surfacePosition);
                                const satVelVec = new THREE.Vector3(instance.velocity.x, instance.velocity.z, -instance.velocity.y).normalize();
                                instance.swath.up.copy(satVelVec);
                                instance.swath.lookAt(earth.position);
                                instance.beam.position.copy(surfacePosition);
                                instance.beam.up.copy(satVelVec);
                                instance.beam.lookAt(instance.mesh.position);
                                instance.beam.scale.z = surfacePosition.distanceTo(instance.mesh.position);
                             }
                            
                            // --- OPTIMIZED SWATH RECORDING (de-nested from the live visibility check) ---
                            // This block now runs for all constellation instances, and the day/night check
                            // is correctly handled inside the addSnapshot function.
                            if (sat.isSwathRecording) {
                                // This helper function calculates the matrix for a new swath segment 
                                // and adds it to the appropriate InstancedMesh, which is highly performant.
                                const addSnapshot = (inst, position3D, upVector) => {
                                    if (inst.swathCount >= MAX_SWATH_SNAPSHOTS) return; // Stop if we reach the max pre-allocated count

                                    const isSnapshotDaySide = position3D.clone().normalize().dot(sunPosition.clone().normalize()) > 0.1;
                                    if (!enforceDayNightSwath || isSnapshotDaySide) {
                                        
                                        // Use the provided 'upVector' for orientation. This is more accurate for interpolated segments.
                                        const satVelocityVector = upVector;
                                        
                                        // Guard against a zero or near-zero velocity vector. A zero vector 
                                        // becomes NaN after normalization, which corrupts the object's matrix
                                        // and causes it to render at a garbage position.
                                        if (satVelocityVector.lengthSq() < 0.0001) {
                                            return; // Skip this snapshot if velocity is negligible.
                                        }
                                        satVelocityVector.normalize();

                                        // Use the reusable dummy object to calculate the matrix
                                        dummyMatrixObject.position.copy(position3D.clone().normalize().multiplyScalar(EARTH_RADIUS_SCALED * 1.0005));
                                        dummyMatrixObject.up.copy(satVelocityVector);
                                        dummyMatrixObject.lookAt(earth.position);
                                        
                                        // Transform the matrix to be relative to the Earth's rotation
                                        earth.worldToLocal(dummyMatrixObject.position);
                                        dummyMatrixObject.quaternion.premultiply(earth.quaternion.clone().invert());
                                        dummyMatrixObject.updateMatrix();

                                        // Alternate between yellow and orange meshes
                                        const isYellow = inst.swathCount % 2 === 0;
                                        const mesh = isYellow ? inst.instancedSwathYellow : inst.instancedSwathOrange;
                                        
                                        // --- BUG FIX ---
                                        // The index for the new matrix must be the current count of instances
                                        // in that specific (yellow or orange) mesh, not an index derived
                                        // from the total swath count. This prevents reusing old matrix slots.
                                        const index = mesh.count;

                                        // Ensure we don't write past the pre-allocated buffer for this mesh.
                                        if (index >= MAX_SWATH_SNAPSHOTS) return;

                                        mesh.setMatrixAt(index, dummyMatrixObject.matrix);
                                        mesh.count = index + 1; // Increment the count for this specific mesh.
                                        mesh.instanceMatrix.needsUpdate = true;
                                        
                                        inst.swathCount++;
                                    }
                                };
                                
                                if (instance.needsSnapshotReset) {
                                    // For the first snapshot, the best 'up' vector is the current satellite velocity.
                                    const initialUp = new THREE.Vector3(instance.velocity.x, instance.velocity.z, -instance.velocity.y);
                                    addSnapshot(instance, instance.mesh.position, initialUp);
                                    instance.lastSnapshotPosition.copy(instance.mesh.position);
                                    instance.needsSnapshotReset = false;
                                }

                                const snapshotDistance = SWATH_SNAPSHOT_DISTANCE_KM * SCALING_FACTOR;
                                // This loop efficiently fills in the path during time-warp without creating new objects
                                while (instance.mesh.position.distanceTo(instance.lastSnapshotPosition) > snapshotDistance) {
                                    const direction = instance.mesh.position.clone().sub(instance.lastSnapshotPosition).normalize();
                                    const nextSnapshotPosition = instance.lastSnapshotPosition.clone().add(direction.multiplyScalar(snapshotDistance));
                                    // For interpolated snapshots, the 'up' vector is the direction of the segment itself.
                                    addSnapshot(instance, nextSnapshotPosition, direction);
                                    instance.lastSnapshotPosition.copy(nextSnapshotPosition);
                                }
                            }
                        }
                    }
                });
            }
            handleCamera(deltaTime);
            controls.update();
            // Smoothly fade out atmosphere when camera is close to prevent visual artifacts
            if (atmosphere && atmosphere.material.uniforms.uOpacity) {
                const startFadeDistance = EARTH_RADIUS_SCALED * 2.5;
                const endFadeDistance = EARTH_RADIUS_SCALED * 1.1;
                const camDistance = camera.position.length();
                const smoothstep = (min, max, value) => {
                    const x = Math.max(0, Math.min(1, (value - min) / (max - min)));
                    return x * x * (3 - 2 * x);
                };
                const opacity = smoothstep(endFadeDistance, startFadeDistance, camDistance);
                atmosphere.material.uniforms.uOpacity.value = opacity;
            }
            if (camera.position.length() < EARTH_RADIUS_SCALED * 1.05) camera.position.setLength(EARTH_RADIUS_SCALED * 1.05);
            
            renderer.render(scene, camera);
        }
        function easeInOutCubic(x) { return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2; }

        function handleCamera(deltaTime) {

            if (cameraTransitionState === 'idle') {

                if (cameraMode === 'satellite' && focusedSatelliteId && trackedSatellites[focusedSatelliteId]) {

                    controls.target.copy(trackedSatellites[focusedSatelliteId].instances[0].mesh.position);

                }

                return; 

            }

            cameraTransitionProgress += deltaTime;

            let alpha = easeInOutCubic(Math.min(cameraTransitionProgress / transitionDuration, 1.0));

            if (cameraTransitionState === 'toSat') {

                if (!focusedSatelliteId || !trackedSatellites[focusedSatelliteId]) { cameraTransitionState = 'idle'; return; }

                const sat = trackedSatellites[focusedSatelliteId].instances[0];

                transitionEndTarget.copy(sat.mesh.position);

                // New logic: Position camera behind and at a slight angle to the satellite

                const direction = sat.mesh.position.clone().normalize();

                const behindVector = direction.clone().multiplyScalar(2.5); // How far behind

                // Get a stable 'side' vector perpendicular to the satellite's position and world 'up'

                const worldUp = new THREE.Vector3(0, 1, 0);

                const sideVector = new THREE.Vector3().crossVectors(direction, worldUp).normalize().multiplyScalar(1.0); // How far to the side

                transitionEndPosition.copy(sat.mesh.position)

                    .add(behindVector)

                    .add(sideVector);

                camera.position.copy(transitionStartPosition).lerp(transitionEndPosition, alpha);

                controls.target.copy(transitionStartTarget).lerp(transitionEndTarget, alpha);

            } else if (cameraTransitionState === 'toEarth') {

                camera.position.copy(transitionStartPosition).lerp(transitionEndPosition, alpha);

                controls.target.copy(transitionStartTarget).lerp(transitionEndTarget, alpha);

            }

            if (alpha >= 1.0) {

                if(cameraTransitionState === 'toSat') controls.target.copy(trackedSatellites[focusedSatelliteId].instances[0].mesh.position);

                else if (cameraTransitionState === 'toEarth') controls.target.set(0,0,0);

                cameraTransitionState = 'idle';

            }

        }

        

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;

            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

            Object.values(trackedSatellites).forEach(sat => {

                if (sat.orbit && sat.orbit.material.isLineMaterial) {

                    sat.orbit.material.resolution.set(window.innerWidth, window.innerHeight);

                }

            });

        }

        init();

    </script>

</body>

</html>

